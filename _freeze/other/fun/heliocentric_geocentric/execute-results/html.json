{
  "hash": "770c48e86d93b31c3c14b551fff8ef78",
  "result": {
    "markdown": "---\ntitle: Heliocentrism vs Geocentrism\nauthor: Connor Robertson\nexecute:\n  daemon: true\n---\n\n## Overview\nAnother fun little animation that I saw recently was the difference in the dynamics of the solar system when approaching the equations from a heliocentric (sun-centered) or geocentric (Earth-centered) perspective.\nAlthough it's clear now that we orbit the sun and a sun-centered model of the solar system is more correct, it wasn't always obvious.\nThis concept extends to systems that we have not yet nailed down completely.\nThis [simple animation](https://www.youtube.com/watch?v=7n7xaviepKM&t=556s) demonstrates that identifying the correct perspective when modeling a system can have a huge pay off in the simplicity of your result.\n\nI thought I'd try to recreate this little animation with `Makie.jl` as I did previously with the [polygon GIF](polygon_angles.qmd).\n\n## Setting up\nIn this animation, we'll be rotating some circular shapes around the point representing either the sun or the Earth and tracing their paths as they progress.\nFirst, let's plot the initial frame of the animation using a `Figure` with 2 `axes`:\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing Pkg;\nPkg.activate(\".\");\nusing CairoMakie;\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nf = Figure(resolution=(800,400));\naxes = [Axis(f[1,1]);Axis(f[1,2])]\nfor ax in axes ax.limits=(-22,22,-22,22) end\nfunction remove_axis_decor!(ax)\n  ax.topspinevisible = false; ax.bottomspinevisible = false\n  ax.leftspinevisible = false; ax.rightspinevisible = false\n  ax.xgridvisible = false; ax.ygridvisible = false\n  ax.xticksvisible = false; ax.yticksvisible = false\n  ax.xticklabelsvisible = false; ax.yticklabelsvisible = false\nend\nremove_axis_decor!.(axes)\n```\n:::\n\n\nWe can now layout the different planets via a simple scatter plot in each `axis`.\nOf course, we cannot use the correct proportions or distances or the plot would be hard to understand.\nInstead, I'll settle for simple size differences between the planets and the sun and a somewhat uniform distance between each.\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nnum_bodies = 9\nbody_locs1 = [(float(i),0.0) for i in 0:2:2(num_bodies-1)]\nbody_locs2 = [(float(i),0.0) for i in -6:2:2(num_bodies-1)-6]\nbody_sizes = 3 .* [9,3,3,4,2,5,6,4,4]\nbody_colors = [:yellow,:red,:red,:blue,:red,:red,:red,:red,:red]\ns1 = scatter!(axes[1], body_locs1, markersize=body_sizes, color=body_colors)\ns2 = scatter!(axes[2], body_locs2, markersize=body_sizes, color=body_colors)\ndisplay(f)\n```\n\n::: {.cell-output .cell-output-display}\n![](heliocentric_geocentric_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\n## Animation\nOkay!\nEasy as that.\nNow, we can move on to animating the rotation of the bodies.\nEach planet will rotate at a different speed and will go until again lining up as they started.\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nbody_speeds = [0.0,47.87,35.02,29.78,24.077,13.07,9.69,6.81,5.43] ./ 200\nsun_speed2 = body_speeds[4]\norbit_radii1 = [bl[1] for bl in body_locs1]\norbit_radii2 = [bl[1] for bl in body_locs2]\n\n# Use Observable to add time dependence to planet locations\ntime_i = Observable(0.0)\nbody_xs1 = @lift(orbit_radii1 .* cos.(-1 .* body_speeds .* $time_i))\nbody_ys1 = @lift(orbit_radii1 .* sin.(-1 .* body_speeds .* $time_i))\nbody_xs2 = @lift(vcat(\n    orbit_radii2[1]*cos(-sun_speed2*$time_i),\n    orbit_radii2[1]*cos(-sun_speed2*$time_i) + orbit_radii1[2]*cos(-body_speeds[2]*$time_i),\n    orbit_radii2[1]*cos(-sun_speed2*$time_i) + orbit_radii1[3]*cos(-body_speeds[3]*$time_i),\n    0.0,\n    orbit_radii2[1]*cos(-sun_speed2*$time_i) .+ orbit_radii1[5:end] .* cos.(-1 .* body_speeds[5:end] .* $time_i)\n))\nbody_ys2 = @lift(vcat(\n    orbit_radii2[1]*sin(-sun_speed2*$time_i),\n    orbit_radii2[1]*sin(-sun_speed2*$time_i) + orbit_radii1[2]*sin(-body_speeds[2]*$time_i),\n    orbit_radii2[1]*sin(-sun_speed2*$time_i) + orbit_radii1[3]*sin(-body_speeds[3]*$time_i),\n    0.0,\n    orbit_radii2[1]*sin(-sun_speed2*$time_i) .+ orbit_radii1[5:end] .* sin.(-1 .* body_speeds[5:end] .* $time_i)\n))\n\nempty!(axes[1].scene.plots)\nempty!(axes[2].scene.plots)\ns1 = scatter!(axes[1], body_xs1, body_ys1, markersize=body_sizes, color=body_colors)\ns2 = scatter!(axes[2], body_xs2, body_ys2, markersize=body_sizes, color=body_colors)\n\n# Create GIF by iterating time\nsteps = 300\nrecord(f, \"gifs/heliocentric_geocentric1.gif\", 1:steps) do t\n    time_i[] = t\nend\n```\n:::\n\n\n![](gifs/heliocentric_geocentric1.gif)\n\nNice! \nWe've got the two animations moving well.\nNote that since the animation was fairly straightforward and only required updating the scatter plot locations, we were able to use an `Observable` for time in `Makie`.\nThis object allows us to create the initial scatter plots where the scatter locations are wrapped with the `@lift` macro with the interpolating `$time_i`.\nNow, when our `Observable`, `time_i` is updated, the scatter points and subsequently the scatter plots are updated.\nUsing this nifty tool, our recording loop is very straightforward.\nHowever, using the `@lift` macro is not particularly intuitive and it took some trial and error to get the definition of the scatter points correctly wrapped in an `Observable`.\nHence, the definitions of `body_xs2` and `body_ys2` are so messy..\n\nOur next step is to add the path tracing of the planets to each plot.\nAgain, this is a fairly simple procedure that could be completed with an `Observable`.\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n# Line observables\nline_locs1 = [Observable([body_locs1[i]]) for i in 1:num_bodies]\nline_locs2 = [Observable([body_locs2[i]]) for i in 1:num_bodies]\n\nempty!(axes[1].scene.plots)\nempty!(axes[2].scene.plots)\nfor i in 1:num_bodies\n    lines!(axes[1], line_locs1[i], color=body_colors[i])\n    lines!(axes[2], line_locs2[i], color=body_colors[i])\nend\ns1 = scatter!(axes[1], body_xs1, body_ys1, markersize=body_sizes, color=body_colors)\ns2 = scatter!(axes[2], body_xs2, body_ys2, markersize=body_sizes, color=body_colors)\n\n# Create GIF by iterating time\nsteps = 300\nrecord(f, \"gifs/heliocentric_geocentric.gif\", 1:steps) do t\n    time_i[] = t\n    for i in 1:num_bodies\n        line_locs1[i][] = push!(line_locs1[i][], (body_xs1[][i], body_ys1[][i]))\n        line_locs2[i][] = push!(line_locs2[i][], (body_xs2[][i], body_ys2[][i]))\n    end\nend\n```\n:::\n\n\n![](gifs/heliocentric_geocentric.gif)\n\nAlright!\nOur animation is now complete.\n\n",
    "supporting": [
      "heliocentric_geocentric_files"
    ],
    "filters": [],
    "includes": {}
  }
}