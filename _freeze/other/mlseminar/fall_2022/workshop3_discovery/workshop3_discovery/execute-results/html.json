{
  "hash": "c7868d663bdf4dc1b71b4359041d1b25",
  "result": {
    "markdown": "---\ntitle: \"Workshop 3: Data-driven discovery via Sparse Identification of Nonlinear Dynamics (SINDy) with neural network approximation and differentiation\"\ncsl: ../../american-physics-society.csl\nbibliography: ../../workshops.bib\nauthor: Connor Robertson\nexecute:\n    daemon: 500\n    keep-ipynb: true\n---\n\n## Overview\n\nOne common hallmark of popular machine learning methods is their \"black-box\" nature.\nSince many of these methods are meant solely for prediction, this has not been too much of an issue.\nAfter all, a black box method can be as complex as needed since it does not need to be analyzed after the fact.\nThis mentality has given birth to increasingly complex but effective models (just take a look at [the model](https://nikcheerla.github.io/deeplearningschool//media/alphago_arch.png) that defeated the worlds best Go player).\n\nHowever, there has been some recent interest in models that can be understood and analyzed.\nThis is particularly true in the scientific realm, where practicioners looking to use machine learning would like to get an idea of the mechanisms underlying their system of study.\nIn order to do so, new tools have been created and old, interpretable tools, such as linear regression, have been adapted to meet this challenge.\n\nMany of these new, interpretable, models have been named \"data-driven model discovery.\"\nTheir goals is to model collected data from a system with machine learning tools to determine a human-readable model.\n\n## Sparse Identification of Nonlinear Dynamics\nOne method for model discovery as described above is called Sparse Identification of Nonlinear Dynamics (SINDy)[@brunton2016discovering].\nThe goal of this method is to extract the most probable differential equation directly from data of the important state variables of a continuum system.\n\n### Setting up linear problem\nAs its name suggests, this method works discover models for linear or nonlinear systems.\nIt is based on a simple idea that nonlinear differential equations can be expressed as a linear combination of nonlinear terms[@williams2015data].\nAssuming we are looking at the nonlinear time evolution of some quantity, this could then be written as the sum of $K$ nonlinear terms:\n$$\nu_t(x,t) = \\xi_1\\mathcal{N}_1(u,x,t) + \\ldots + \\xi_K\\mathcal{N}_K(u,x,t)\n$$\nIf we can then determine what nonlinear terms are possible $\\mathcal{N}_i(u,x,t)$, we can sift through these terms to determine which best contribute to the time evolution of the system.\n\nUltimately, this boils down to a regression problem.\nGiven some space and time samples of our state variable: $u(x_i,t_j)$ for $i \\leq N$ and $j \\leq M$, we can consider the linear system:\n$$\nu_t(x_i,t_j) = \\xi_1\\mathcal{N}_1(u_{ij},x_i,t_j) + \\ldots + \\xi_K\\mathcal{N}_K(u_{ij},x_i,t_j)\n$$\nExpanded for all the data samples (flattened across space and time), this can be written as the system:\n$$\n\\begin{bmatrix}\nu_t(x_1, t_1) \\\\\n\\vdots \\\\\nu_t(x_N, t_1) \\\\\n\\vdots \\\\\nu_t(x_N, t_M) \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\mathcal{N}_1(x_1, t_1) & \\ldots & \\mathcal{N}_K(x_1, t_1) \\\\\n\\vdots &  & \\vdots \\\\\n\\mathcal{N}_1(x_N, t_1) & \\ldots & \\mathcal{N}_K(x_1, t_1) \\\\\n\\vdots &  & \\vdots \\\\\n\\mathcal{N}_1(x_N, t_M) & \\ldots & \\mathcal{N}_K(x_1, t_1)\n\\end{bmatrix}\n\\vec{\\xi}\n$$ {#eq-linear-system}\n\nSolving this system is then a straightforward linear regression.\n\n### Determining nonlinear \"library\" of terms\nDetermining what $\\mathcal{N}_i(u,x,t)$ are reasonable for the system is somewhat of a traditional modeling problem.\nAre there any symmetries in the system that need to be satisfied?\nIs there periodic behavior that might warrant inclusion of trignometric terms?\nWhat order of polynomial interactions are possible for the system?\n\nThe most common library of terms for a 1D function is to put together polynomial interactions with spatial derivatives.\nSuch a library up to 3rd order polynomials and derivatives could be written:\n$$\n\\begin{align*}\n\\mathcal{N}_1(u,x,t) &= u\\\\\n\\mathcal{N}_2(u,x,t) &= u^2\\\\\n&\\vdots \\\\\n\\mathcal{N}_i(u,x,t) &= u_x\\\\\n\\mathcal{N}_{i+1}(u,x,t) &= u_x^2\\\\\n&\\vdots \\\\\n\\mathcal{N}_K(u,x,t) &= u^3u_{xxx}\\\\\n\\end{align*}\n$$\n\n### Numerical differentiation of the terms\nIn order to actually compute the values in the linear system written in @eq-linear-system, we must compute numerical derivatives in both $t$ and in $x$.\nThis isn't an issue if we have smooth, reliable data and can be quickly computed with finite differences.\n\nHowever, the intent of this method is to use data samples $u(x_i,t_j)$ that are collected from the real world, implying that they will each be polluted with some level of noise.\nThere have been several classical methods presented for dealing with numerical differentiation of noisy data that could be used, but generally the methods revolve around an approximate fitting of a differentiable function basis to the data.\nNotable among these are:\n\n- Local polynomial regression (LOESS[@cleveland1988locally], Savitsky-Golay filter[@press1990savitzky], etc.)\n- Radial basis functions (Gaussian kernel) \n- Smoothing splines\n- Least squares spectral analysis (LSSA)\n\nThese can be written along the lines of:\n$$\n\\underset{\\vec{c}}{\\text{argmin}} \\; \\sum_{i,j}^{N,M}\\|u(x_i,t_j) - F(x_i,t_j,\\vec{c})\\|_2\n$$\nwhere\n$$\nF(x_i,t_j,\\vec{c}) = \\sum_l^L c_l \\phi_l(x_i,t_j)\n$$\nand $\\phi$ represents our chosen basis function.\nOnce computed, we can easily approximate derivatives of $u$ via:\n$$\nu_x(x_i,t_j) \\approx F_x(x_i,t_j,\\vec{c}) = \\sum_l^L c_l \\frac{d}{dx}\\phi_l(x_i,t_j)\n$$\n\n\n\nEach of these has the goal of smoothing the given data while simultaneously providing an exact derivative of the approximation.\nThis is a similar idea as we have discussed with automatic differentiation of neural networks.\nIn fact, you could consider fitting a neural network to be the same as fitting a randomly initialized nested basis of nonlinear functions (since they are dense according to the universal approximation theorem).\nWe will explore this idea in the example problem in @sec-simulated.\n\n### Sparse regression\nOnce the matrix in @eq-linear-system has been created using numerical differentiation, it remains to sift through the nonlinear terms to determine which, if any, contribute to the time evolution of our state variable of interest.\nIt is usually reasonable to consider that not all the nonlinear terms should be included in the equation, so we would like to determine the most parsimonious (smallest) combination of them that will capture our desired qualitative and quantitative behavior in the system.\n\nThere are two main families of sparse regression methods:\n\n**Greedy methods**: Iterative add/remove terms that best match the time derivative in some metric ($R^2$ coefficient of determination, Akaike Information Criteria (AIC), etc.).\n\n- Forward selection: Start with no terms, add one by one according to which maximizes $R^2$ or AIC at each step\n- Backward selection: Start with all terms, remove one by one according to which least reduces $R^2$ or AIC\n- (Orthogonal) Matching pursuit: Start with no terms, add one by one according to which maximizes correlation (orthogonalizing after each step)\n\n**Regularization methods**: Add a penalty to the regression for having too many terms or large coefficients $\\xi_i$.\nThese can be written roughly as:\n$$\n\\underset{\\vec{\\xi}}{\\text{argmin}}\\; \\|u_t(x_i,t_j) - \\mathbf{\\mathcal{N}}(u_{ij},x_i,t_j) \\cdot \\vec{\\xi}\\|_2^2 + \\lambda \\|\\xi\\|_C\n$$\n\n- Ridge regression: Let $C=2$ forcing coefficients $\\vec{\\xi}$ to be smaller. We hope that important coefficients will remain larger while unimportant ones shrink.\n- Lasso regression: Let $C=1$ forcing coefficients $\\vec{\\xi}$ to be smaller and various to be set to 0 (due to the geometry of the 1-norm).\n- 0-norm regression: Let $C=0$ which is a measure that counts the number of nonzero coefficients in $\\vec{\\xi}$. Computing this usually requires a combination of regularization and relaxation best captured by the SR3 method[@zheng2018unified].\n\nCombinations of these two methods which iterative perform regularization methods removing terms with small coefficients according to a given threshold have also been proposed (Sequential Threshold Ridge Regression[@rudy2017data] or the original SINDy algorithm[@brunton2016discovering]).\n\n### Summary of the method\nIn summary, the procedure to use SINDy is as follows:\n\n1. Collect sample points of a continuum state variable of interest $u(x_i,t_j)$\n2. Form a \"library\" of possible terms for the differential model of the system $\\mathcal{N}_k(u,x,t)$\n3. Compute the libary at sample points using noise robust numerical differentiation to compute both $u_t(x_i,t_j)$ and $\\mathcal{N}_k(u_{ij},x_i,t_j)$\n4. Use sparse regression to determine a sparse vector $\\vec{\\xi}$ which closely approximates $u_t(x_i,t_j) = \\xi_1\\mathcal{N}_1(u_{ij},x_i,t_j) + \\ldots + \\xi_K\\mathcal{N}_K(u_{ij},x_i,t_j)$\n\nTo really explore this method, we will walk through this process using simulated traveling wave data in @sec-simulated and using real extracted data in @sec-extracted.\n\n## Application to simulated wave data {#sec-simulated}\n\n:::{.callout-note}\nFor this workshop you will need to install the following packages:\n\n```bash\nmamba install numpy matplotlib py-pde sympy jax optax flax scikit-learn scikit-image av\n```\n:::\n\nGiven some data generated via finite differences of the simple advection equation:\n$$\nh_t(x,t) = h_x(x,t)\n$$\nwith periodic boundaries and a Gaussian initial condition, we have the following measurement of state variable $h$ (height of the wave):\n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"Generate simple wave data\"}\nimport numpy as np\nimport pde\nimport matplotlib.pyplot as plt\n\n# Domain\nxmax = 1.0\nnx = 100\ndt = 1e-6\ntmax = 1.0-2*dt\nsave_dt = 0.01\ninit_cond = \".1*exp(-(1/.01)*(x-0.3)**2)\"\n\ngrid = pde.CartesianGrid([(0.0,xmax)],nx,periodic=True)\nh = pde.ScalarField.from_expression(grid,init_cond,label=\"h(x,t)\")\neq = pde.PDE({\"h\": \"-d_dx(h)\"})\nstorage = pde.MemoryStorage()\n\nresult = eq.solve(h,t_range=tmax,dt=dt,tracker=storage.tracker(save_dt),ret_info=False)\n\n# pde.plot_kymograph(storage)\nmovie = pde.visualization.movie(storage,\"simple_wave.gif\")\n\nh=np.array(storage.data)\nx=storage.grid.coordinate_arrays[0]\nt=np.array(storage.times)\nnp.savez(\"simple_wave.npz\",h=h,x=x,t=t)\nplt.close()\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<script type=\"application/vnd.jupyter.widget-view+json\">\n{\"model_id\":\"1827f7184483491eab642992211af638\",\"version_major\":2,\"version_minor\":0}\n</script>\n```\n:::\n:::\n\n\n![](simple_wave.gif)\n\n### Generating nonlinear library\nGenerating a library can be most easily accomplished using the `sympy` symbolic math Python library.\nTo be overly thorough, we will generate up to 4th order polynomial combinations of up to 4th order spatial derivatives.\n\nWe can first initialize our spatial and state variables:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport sympy as sp\n\nx_sym,t_sym = sp.symbols(\"x t\")\nh_sym = sp.Function(\"h\")\n```\n:::\n\n\nGiven a specified order, we can now create symbolic derivative terms (constructed to be most legible):\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n# Library parameters\nmax_poly_order = 4\nmax_diff_order = 4\n\ndiff_terms = [h_sym(x_sym,t_sym)]\ndiff_terms += [sp.Function(str(h_sym)+\"_\"+(i*str(x_sym)))(x_sym,t_sym) for i in range(1,max_diff_order+1)]\nprint(diff_terms)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[h(x, t), h_x(x, t), h_xx(x, t), h_xxx(x, t), h_xxxx(x, t)]\n```\n:::\n:::\n\n\nNow, combining these into polynomials up to 4th order (again, this is overkill, but for a system you don't fully understand, you may want to have a very complete library):\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nfrom itertools import combinations_with_replacement\n\nterms = []\nfor po in range(max_poly_order+1):\n    if po == 0:\n        term = sp.core.numbers.One()\n    else:\n        combos = combinations_with_replacement(diff_terms,po)\n        for combo in combos:\n            term = 1\n            for combo_term in combo:\n                term *= combo_term\n            terms.append(term)\nprint(terms)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[h(x, t), h_x(x, t), h_xx(x, t), h_xxx(x, t), h_xxxx(x, t), h(x, t)**2, h(x, t)*h_x(x, t), h(x, t)*h_xx(x, t), h(x, t)*h_xxx(x, t), h(x, t)*h_xxxx(x, t), h_x(x, t)**2, h_x(x, t)*h_xx(x, t), h_x(x, t)*h_xxx(x, t), h_x(x, t)*h_xxxx(x, t), h_xx(x, t)**2, h_xx(x, t)*h_xxx(x, t), h_xx(x, t)*h_xxxx(x, t), h_xxx(x, t)**2, h_xxx(x, t)*h_xxxx(x, t), h_xxxx(x, t)**2, h(x, t)**3, h(x, t)**2*h_x(x, t), h(x, t)**2*h_xx(x, t), h(x, t)**2*h_xxx(x, t), h(x, t)**2*h_xxxx(x, t), h(x, t)*h_x(x, t)**2, h(x, t)*h_x(x, t)*h_xx(x, t), h(x, t)*h_x(x, t)*h_xxx(x, t), h(x, t)*h_x(x, t)*h_xxxx(x, t), h(x, t)*h_xx(x, t)**2, h(x, t)*h_xx(x, t)*h_xxx(x, t), h(x, t)*h_xx(x, t)*h_xxxx(x, t), h(x, t)*h_xxx(x, t)**2, h(x, t)*h_xxx(x, t)*h_xxxx(x, t), h(x, t)*h_xxxx(x, t)**2, h_x(x, t)**3, h_x(x, t)**2*h_xx(x, t), h_x(x, t)**2*h_xxx(x, t), h_x(x, t)**2*h_xxxx(x, t), h_x(x, t)*h_xx(x, t)**2, h_x(x, t)*h_xx(x, t)*h_xxx(x, t), h_x(x, t)*h_xx(x, t)*h_xxxx(x, t), h_x(x, t)*h_xxx(x, t)**2, h_x(x, t)*h_xxx(x, t)*h_xxxx(x, t), h_x(x, t)*h_xxxx(x, t)**2, h_xx(x, t)**3, h_xx(x, t)**2*h_xxx(x, t), h_xx(x, t)**2*h_xxxx(x, t), h_xx(x, t)*h_xxx(x, t)**2, h_xx(x, t)*h_xxx(x, t)*h_xxxx(x, t), h_xx(x, t)*h_xxxx(x, t)**2, h_xxx(x, t)**3, h_xxx(x, t)**2*h_xxxx(x, t), h_xxx(x, t)*h_xxxx(x, t)**2, h_xxxx(x, t)**3, h(x, t)**4, h(x, t)**3*h_x(x, t), h(x, t)**3*h_xx(x, t), h(x, t)**3*h_xxx(x, t), h(x, t)**3*h_xxxx(x, t), h(x, t)**2*h_x(x, t)**2, h(x, t)**2*h_x(x, t)*h_xx(x, t), h(x, t)**2*h_x(x, t)*h_xxx(x, t), h(x, t)**2*h_x(x, t)*h_xxxx(x, t), h(x, t)**2*h_xx(x, t)**2, h(x, t)**2*h_xx(x, t)*h_xxx(x, t), h(x, t)**2*h_xx(x, t)*h_xxxx(x, t), h(x, t)**2*h_xxx(x, t)**2, h(x, t)**2*h_xxx(x, t)*h_xxxx(x, t), h(x, t)**2*h_xxxx(x, t)**2, h(x, t)*h_x(x, t)**3, h(x, t)*h_x(x, t)**2*h_xx(x, t), h(x, t)*h_x(x, t)**2*h_xxx(x, t), h(x, t)*h_x(x, t)**2*h_xxxx(x, t), h(x, t)*h_x(x, t)*h_xx(x, t)**2, h(x, t)*h_x(x, t)*h_xx(x, t)*h_xxx(x, t), h(x, t)*h_x(x, t)*h_xx(x, t)*h_xxxx(x, t), h(x, t)*h_x(x, t)*h_xxx(x, t)**2, h(x, t)*h_x(x, t)*h_xxx(x, t)*h_xxxx(x, t), h(x, t)*h_x(x, t)*h_xxxx(x, t)**2, h(x, t)*h_xx(x, t)**3, h(x, t)*h_xx(x, t)**2*h_xxx(x, t), h(x, t)*h_xx(x, t)**2*h_xxxx(x, t), h(x, t)*h_xx(x, t)*h_xxx(x, t)**2, h(x, t)*h_xx(x, t)*h_xxx(x, t)*h_xxxx(x, t), h(x, t)*h_xx(x, t)*h_xxxx(x, t)**2, h(x, t)*h_xxx(x, t)**3, h(x, t)*h_xxx(x, t)**2*h_xxxx(x, t), h(x, t)*h_xxx(x, t)*h_xxxx(x, t)**2, h(x, t)*h_xxxx(x, t)**3, h_x(x, t)**4, h_x(x, t)**3*h_xx(x, t), h_x(x, t)**3*h_xxx(x, t), h_x(x, t)**3*h_xxxx(x, t), h_x(x, t)**2*h_xx(x, t)**2, h_x(x, t)**2*h_xx(x, t)*h_xxx(x, t), h_x(x, t)**2*h_xx(x, t)*h_xxxx(x, t), h_x(x, t)**2*h_xxx(x, t)**2, h_x(x, t)**2*h_xxx(x, t)*h_xxxx(x, t), h_x(x, t)**2*h_xxxx(x, t)**2, h_x(x, t)*h_xx(x, t)**3, h_x(x, t)*h_xx(x, t)**2*h_xxx(x, t), h_x(x, t)*h_xx(x, t)**2*h_xxxx(x, t), h_x(x, t)*h_xx(x, t)*h_xxx(x, t)**2, h_x(x, t)*h_xx(x, t)*h_xxx(x, t)*h_xxxx(x, t), h_x(x, t)*h_xx(x, t)*h_xxxx(x, t)**2, h_x(x, t)*h_xxx(x, t)**3, h_x(x, t)*h_xxx(x, t)**2*h_xxxx(x, t), h_x(x, t)*h_xxx(x, t)*h_xxxx(x, t)**2, h_x(x, t)*h_xxxx(x, t)**3, h_xx(x, t)**4, h_xx(x, t)**3*h_xxx(x, t), h_xx(x, t)**3*h_xxxx(x, t), h_xx(x, t)**2*h_xxx(x, t)**2, h_xx(x, t)**2*h_xxx(x, t)*h_xxxx(x, t), h_xx(x, t)**2*h_xxxx(x, t)**2, h_xx(x, t)*h_xxx(x, t)**3, h_xx(x, t)*h_xxx(x, t)**2*h_xxxx(x, t), h_xx(x, t)*h_xxx(x, t)*h_xxxx(x, t)**2, h_xx(x, t)*h_xxxx(x, t)**3, h_xxx(x, t)**4, h_xxx(x, t)**3*h_xxxx(x, t), h_xxx(x, t)**2*h_xxxx(x, t)**2, h_xxx(x, t)*h_xxxx(x, t)**3, h_xxxx(x, t)**4]\n```\n:::\n:::\n\n\n### Approximating data\nIn order to provide numerical derivatives of our data, we will use a neural network approximation.\n\n:::{.callout-note}\nThis is far beyond what is necessary for this particular setting, but is a method that can generalize to data outside of a grid and in high dimension, so is fairly robust.\nThe lack of requirement for a grid can also help with robustly fitting to noisy data by using a train-test methodology in @sec-noisy which classical basis functions do not handle well.\n:::\n\nTo begin, we will be using the Google developed [`flax`](https://flax.readthedocs.io/en/latest/) neural network framework which is built on their [`jax`](https://jax.readthedocs.io/en/latest/index.html) automatic differentiation library and the [`optax`](https://optax.readthedocs.io/en/latest/optax-101.html) optimization library.\nThe reason for this will become clearer when we consider taking a fourth order derivative in $x$ of the network, a task which many other popular frameworks (`pytorch`, `keras`, `tensorflow`, etc.) cannot do (at least not nearly as concisely).\nHowever, the `jax` library is state-of-the-art for automatic differentiation and is used heavily for differentiable programming and neural network research today (see Appendix for more information). <!-- TODO: Write appendix section briefly lauding how JAX works)-->\n\n#### Creating the neural network model\nFirst, we will create a simple dense neural network model using the $\\tanh$ activation (to ensure a smooth approximation):\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport flax.linen as nn\n\nclass MyNet(nn.Module):\n    @nn.compact\n    def __call__(self, x):\n        x = nn.Dense(60)(x)\n        x = nn.tanh(x)\n        x = nn.Dense(12)(x)\n        x = nn.tanh(x)\n        x = nn.Dense(1)(x)\n        return x\n```\n:::\n\n\nThis model will take an input of $(x_i,t_j)$ (a dimension 2 array), linearly map it to a dimension 60 space, apply a tanh activation, linearly map to a dimension 12 space, apply a tanh activation, then linearly map to a dimension 1 output (this particular width and depth was chosen arbitrarily).\n\nWe next initialize the parameters of the network (each of the linear transformation matrices) and print out the dimensions of the corresponding arrays:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nimport jax\njax.config.update(\"jax_platform_name\", \"cpu\")\n\n# Random generator seed\nrng1,rng2 = jax.random.split(jax.random.PRNGKey(42))\nrandom_data = jax.random.normal(rng1,(2,))\nmodel1 = MyNet()\nparams1 = model1.init(rng2,random_data)\nprint(jax.tree_util.tree_map(lambda x: x.shape, params1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFrozenDict({\n    params: {\n        Dense_0: {\n            bias: (60,),\n            kernel: (2, 60),\n        },\n        Dense_1: {\n            bias: (12,),\n            kernel: (60, 12),\n        },\n        Dense_2: {\n            bias: (1,),\n            kernel: (12, 1),\n        },\n    },\n})\n```\n:::\n:::\n\n\n:::{.callout-note}\nThe confusing `tree_util.tree_map` command is a convenience function for mapping a function (in this case `lambda x: x.shape`) across a set of different objects.\nThis is useful because these objects can be arrays, dictionaries, lists, classes (i.e. other neural networks), etc.\n:::\n\n#### Loading and processing data\nIn order to fit this model to the data, we must load the data into batches of $(x_i,t_j,u(x_i,t_j))$ points.\nSince our data is known to be quite smooth and we want to maximize the fit, we will use batches of size 10000:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nimport jax.numpy as jnp\n\ndef load_data(data_path,noise_scale=0):\n    raw_data = np.load(data_path)\n    h = raw_data[\"h\"].astype(jnp.float32)\n    x = raw_data[\"x\"].astype(jnp.float32)\n    t = raw_data[\"t\"].astype(jnp.float32)\n\n    # Add noise if needed\n    h += noise_scale*jnp.std(h)*np.random.normal(size=h.shape)\n\n    # Mean center, std center data\n    h = (h - jnp.mean(h)) / jnp.std(h)\n    x = (x - jnp.mean(x)) / jnp.std(x)\n    t = (t - jnp.mean(t)) / jnp.std(t)\n    return x,t,h\n\ndef batch_data(x,t,h,batch_size):\n    # Split data into batches\n    data = []\n    for i in range(0,len(x),batch_size):\n        temp_xt = jnp.vstack((x[i:i+batch_size], t[i:i+batch_size])).T\n        temp_h = h[i:i+batch_size].reshape((-1,1))\n        data.append((temp_xt,temp_h))\n    return data\n\nx,t,h = load_data(\"simple_wave.npz\")\nX,T = jnp.meshgrid(x,t)\ndata = batch_data(X.flatten(),T.flatten(),h.flatten(),10000)\n```\n:::\n\n\nNote that the data needed to be centered and scaled to have a mean of $\\bar{h}=0$ and standard deviation of $\\overline{(h - \\bar{h})}=1$ in order to best use the $\\tanh$ activation (which extends from -1 to 1). \n\n#### Training the model\nWe will use the mean squared error fit of the data to our neural network output (just in time compiled with `@jax.jit` for maximum speed):\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\n@jax.jit\ndef mse(params,input,targets):\n    def squared_error(x,y):\n        pred = model1.apply(params,x)\n        return jnp.mean((y - pred)**2)\n    return jnp.mean(jax.vmap(squared_error)(input,targets),axis=0)\nloss_grad_fn = jax.value_and_grad(mse)\n```\n:::\n\n\nWith this loss defined, we initialize an ADAM optimizer and optimizer state and wrap the loss function to return both the output and gradient:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nimport optax\n\nlearning_rate = 1e-2\ntx = optax.adam(learning_rate)\nopt_state = tx.init(params1)\n```\n:::\n\n\nWe can now train the model to take in $(x_i,t_j)$ and output $u(x_i,t_j)$.\nPerforming 1000 iterations over the data, we will print the mean squared error on the data as we proceed with the training:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nepochs = 1000\nall_xt = jnp.array([data[i][0] for i in range(len(data))])\nall_h = jnp.array([data[i][1] for i in range(len(data))])\nfor i in range(epochs):\n    xt_batch = data[i%len(data)][0]\n    h_batch = data[i%len(data)][1]\n    loss_val, grads = loss_grad_fn(params1, xt_batch, h_batch)\n    updates, opt_state = tx.update(grads, opt_state)\n    params1 = optax.apply_updates(params1, updates)\n    if i % 100 == 0:\n        train_loss = mse(params1,all_xt,all_h)\n        print(\"Training loss step {}: {}\".format(i,train_loss))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTraining loss step 0: 1.0898101329803467\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTraining loss step 100: 0.16434669494628906\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTraining loss step 200: 0.09155044704675674\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTraining loss step 300: 0.01834404096007347\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTraining loss step 400: 0.0012183969374746084\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTraining loss step 500: 0.0004402332124300301\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTraining loss step 600: 0.000266294606262818\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTraining loss step 700: 0.00018376208026893437\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTraining loss step 800: 0.00013974899775348604\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTraining loss step 900: 0.00011441211245255545\n```\n:::\n:::\n\n\nAs you can tell, this procedure is somewhat more manual than other libraries such as `keras` but keep you closer to the details, allowing for more flexibility in implementation.\n\n#### Validating fit\nThe fit to the model can be visualized as follows:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nimport matplotlib.animation as anim\n\nX,T = jnp.meshgrid(x,t)\nxt_points = jnp.vstack([X.flatten(),T.flatten()]).T\nhhat = model1.apply(params1,xt_points).reshape(X.shape)\ndiff = np.sqrt((h - hhat)**2)\n\ndef animate_data(x,t,data_list,labels):\n    fig = plt.figure()\n    plt.xlabel(\"$x$\")\n    plots = []\n\n    for i in range(len(data_list)):\n        plot = plt.plot(x,data_list[i][0,:],label=labels[i])[0]\n        plots.append(plot)\n\n    def anim_func(j):\n        for i in range(len(plots)):\n            plots[i].set_ydata(data_list[i][j,:])\n        return plots\n\n    plt.legend()\n    approx_anim = anim.FuncAnimation(fig, anim_func, range(len(t)))\n    return approx_anim\n\nanimation1 = animate_data(x,t,[h,hhat,diff],[\"$h$\",\"$\\hat{h}$\",\"$L^2$ error\"])\nanimation1.save(\"clean_h_compare.gif\")\nplt.close()\n```\n:::\n\n\n![](clean_h_compare.gif)\n\n### Numerically differentiating the neural network model\nThe original reason to fit this model to the data was to be able to construct each of the terms in our nonlinear libary for the system.\nIn order to differentiate the model, we must wrap it in a function that takes our inputs and returns the output. \n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ndef model_for_diff(x,t):\n    new_x = jnp.array([x,t])\n    return model1.apply(params1, new_x)[0]\n\n# Take a derivative with respect to the first input (x) at point (x_i,t_j)\nx_i = 0.3; t_j = 0.3\njax.grad(model_for_diff,0)(x_i,t_j)\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n```\nDeviceArray(0.01142633, dtype=float32, weak_type=True)\n```\n:::\n:::\n\n\n:::{.callout-note}\nIf we were to differentiate the model directly, we would compute derivatives for all the parameters!\nThis is the main challenge with using other neural network frameworks for this kind of function approximation.\n:::\nApplying this iteratively, we can construct derivatives $h_x(x,t), \\ldots, h_{xxxx}(x,t)$ as is required by our library:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndiff_term_values = {}\nfor i in range(max_diff_order+1):\n    diff_func = model_for_diff\n    # Iteratively apply derivatives\n    for _ in range(i):\n        diff_func = jax.grad(diff_func, 0)\n    def unpack_diff_func(x):\n        new_x,new_t = x\n        return diff_func(new_x,new_t)\n    diff_term_values[diff_terms[i]] = np.array(jax.lax.map(unpack_diff_func, xt_points))\n```\n:::\n\n\nWe can then reconstruct our terms attaching them to their corresponding values on our $(x,t)$ grid:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\ndef construct_terms(diff_term_values):\n    term_values = {}\n    term_shape = np.shape(diff_term_values[list(diff_term_values.keys())[0]])\n    for order in range(max_poly_order+1):\n        if order == 0:\n            term = sp.core.numbers.One()\n            term_values[term] = np.ones(term_shape)\n        else:\n            combos = combinations_with_replacement(diff_terms,order)\n            for combo in combos:\n                term = 1\n                temp_term_value = 1\n                for combo_term in combo:\n                    term *= combo_term\n                    temp_term_value *= diff_term_values[combo_term]\n                term_values[term] = temp_term_value\n    return term_values\nterm_values = construct_terms(diff_term_values)\n```\n:::\n\n\nFinally, we compute the derivative of the network with respect to time:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\ndef unpack_diff_func(x):\n    new_x,new_t = x\n    return jax.grad(model_for_diff,1)(new_x,new_t)\n\nh_t_term = sp.Function(\"h_t\")(x_sym,t_sym)\nh_t = -np.array(jax.lax.map(unpack_diff_func, xt_points))\n```\n:::\n\n\n### Solving the sparse regression problem\nIn order to cleanly work with our term library, we will use a very popular Python data science package called `pandas`.\nSimply put, this library allows you to easily load, manipulate, and save tabular data.\nHere is our library as a `pandas` `DataFrame`:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nimport pandas as pd\n\nterm_matrix = pd.DataFrame(term_values,index=pd.MultiIndex.from_arrays(np.round(np.array(xt_points),2).T, names=(\"x\",\"t\")))\nterm_matrix\n```\n\n::: {.cell-output .cell-output-display execution_count=16}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th></th>\n      <th>1</th>\n      <th>h(x, t)</th>\n      <th>h_x(x, t)</th>\n      <th>h_xx(x, t)</th>\n      <th>h_xxx(x, t)</th>\n      <th>h_xxxx(x, t)</th>\n      <th>h(x, t)**2</th>\n      <th>h(x, t)*h_x(x, t)</th>\n      <th>h(x, t)*h_xx(x, t)</th>\n      <th>h(x, t)*h_xxx(x, t)</th>\n      <th>...</th>\n      <th>h_xx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**3</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**2*h_xxxx(x, t)</th>\n      <th>h_xx(x, t)*h_xxx(x, t)*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxx(x, t)**4</th>\n      <th>h_xxx(x, t)**3*h_xxxx(x, t)</th>\n      <th>h_xxx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xxx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxxx(x, t)**4</th>\n    </tr>\n    <tr>\n      <th>x</th>\n      <th>t</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>-1.71</th>\n      <th>-1.71</th>\n      <td>1.0</td>\n      <td>-0.585482</td>\n      <td>0.032621</td>\n      <td>0.299091</td>\n      <td>3.230638</td>\n      <td>30.858641</td>\n      <td>0.342789</td>\n      <td>-0.019099</td>\n      <td>-0.175112</td>\n      <td>-1.891480</td>\n      <td>...</td>\n      <td>85.184204</td>\n      <td>10.084811</td>\n      <td>96.328819</td>\n      <td>920.120422</td>\n      <td>8.788872e+03</td>\n      <td>108.931458</td>\n      <td>1040.499268</td>\n      <td>9.938715e+03</td>\n      <td>9.493333e+04</td>\n      <td>9.067909e+05</td>\n    </tr>\n    <tr>\n      <th>-1.68</th>\n      <th>-1.71</th>\n      <td>1.0</td>\n      <td>-0.584148</td>\n      <td>0.045153</td>\n      <td>0.431625</td>\n      <td>4.487586</td>\n      <td>42.299286</td>\n      <td>0.341229</td>\n      <td>-0.026376</td>\n      <td>-0.252133</td>\n      <td>-2.621416</td>\n      <td>...</td>\n      <td>333.333466</td>\n      <td>39.007198</td>\n      <td>367.675781</td>\n      <td>3465.654785</td>\n      <td>3.266672e+04</td>\n      <td>405.556274</td>\n      <td>3822.710205</td>\n      <td>3.603227e+04</td>\n      <td>3.396346e+05</td>\n      <td>3.201342e+06</td>\n    </tr>\n    <tr>\n      <th>-1.65</th>\n      <th>-1.71</th>\n      <td>1.0</td>\n      <td>-0.582291</td>\n      <td>0.063118</td>\n      <td>0.615352</td>\n      <td>6.208448</td>\n      <td>57.810596</td>\n      <td>0.339063</td>\n      <td>-0.036753</td>\n      <td>-0.358314</td>\n      <td>-3.615125</td>\n      <td>...</td>\n      <td>1265.501343</td>\n      <td>147.256027</td>\n      <td>1371.189453</td>\n      <td>12767.969727</td>\n      <td>1.188902e+05</td>\n      <td>1485.703979</td>\n      <td>13834.283203</td>\n      <td>1.288193e+05</td>\n      <td>1.199514e+06</td>\n      <td>1.116940e+07</td>\n    </tr>\n    <tr>\n      <th>-1.61</th>\n      <th>-1.71</th>\n      <td>1.0</td>\n      <td>-0.579688</td>\n      <td>0.088593</td>\n      <td>0.868975</td>\n      <td>8.553134</td>\n      <td>78.522270</td>\n      <td>0.336039</td>\n      <td>-0.051356</td>\n      <td>-0.503735</td>\n      <td>-4.958152</td>\n      <td>...</td>\n      <td>4655.866211</td>\n      <td>543.729858</td>\n      <td>4991.726074</td>\n      <td>45826.671875</td>\n      <td>4.207130e+05</td>\n      <td>5351.814941</td>\n      <td>49132.476562</td>\n      <td>4.510620e+05</td>\n      <td>4.140987e+06</td>\n      <td>3.801644e+07</td>\n    </tr>\n    <tr>\n      <th>-1.58</th>\n      <th>-1.71</th>\n      <td>1.0</td>\n      <td>-0.576034</td>\n      <td>0.124417</td>\n      <td>1.217474</td>\n      <td>11.722404</td>\n      <td>105.592400</td>\n      <td>0.331815</td>\n      <td>-0.071668</td>\n      <td>-0.701306</td>\n      <td>-6.752501</td>\n      <td>...</td>\n      <td>16526.652344</td>\n      <td>1961.145264</td>\n      <td>17665.492188</td>\n      <td>159126.218750</td>\n      <td>1.433368e+06</td>\n      <td>18882.812500</td>\n      <td>170091.531250</td>\n      <td>1.532141e+06</td>\n      <td>1.380113e+07</td>\n      <td>1.243170e+08</td>\n    </tr>\n    <tr>\n      <th>...</th>\n      <th>...</th>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n      <td>...</td>\n    </tr>\n    <tr>\n      <th>1.58</th>\n      <th>1.71</th>\n      <td>1.0</td>\n      <td>-0.593596</td>\n      <td>-0.031917</td>\n      <td>0.124309</td>\n      <td>0.865729</td>\n      <td>5.409935</td>\n      <td>0.352356</td>\n      <td>0.018946</td>\n      <td>-0.073790</td>\n      <td>-0.513894</td>\n      <td>...</td>\n      <td>0.452263</td>\n      <td>0.080658</td>\n      <td>0.504034</td>\n      <td>3.149705</td>\n      <td>1.968248e+01</td>\n      <td>0.561731</td>\n      <td>3.510254</td>\n      <td>2.193554e+01</td>\n      <td>1.370750e+02</td>\n      <td>8.565805e+02</td>\n    </tr>\n    <tr>\n      <th>1.61</th>\n      <th>1.71</th>\n      <td>1.0</td>\n      <td>-0.594621</td>\n      <td>-0.027048</td>\n      <td>0.158013</td>\n      <td>1.093115</td>\n      <td>7.855449</td>\n      <td>0.353574</td>\n      <td>0.016083</td>\n      <td>-0.093958</td>\n      <td>-0.649989</td>\n      <td>...</td>\n      <td>1.540738</td>\n      <td>0.206391</td>\n      <td>1.483188</td>\n      <td>10.658629</td>\n      <td>7.659605e+01</td>\n      <td>1.427789</td>\n      <td>10.260510</td>\n      <td>7.373505e+01</td>\n      <td>5.298819e+02</td>\n      <td>3.807887e+03</td>\n    </tr>\n    <tr>\n      <th>1.65</th>\n      <th>1.71</th>\n      <td>1.0</td>\n      <td>-0.595455</td>\n      <td>-0.020860</td>\n      <td>0.201215</td>\n      <td>1.422090</td>\n      <td>11.353171</td>\n      <td>0.354567</td>\n      <td>0.012421</td>\n      <td>-0.119814</td>\n      <td>-0.846791</td>\n      <td>...</td>\n      <td>5.218610</td>\n      <td>0.578684</td>\n      <td>4.619892</td>\n      <td>36.882626</td>\n      <td>2.944502e+02</td>\n      <td>4.089862</td>\n      <td>32.651169</td>\n      <td>2.606686e+02</td>\n      <td>2.081032e+03</td>\n      <td>1.661379e+04</td>\n    </tr>\n    <tr>\n      <th>1.68</th>\n      <th>1.71</th>\n      <td>1.0</td>\n      <td>-0.596047</td>\n      <td>-0.012948</td>\n      <td>0.258214</td>\n      <td>1.896819</td>\n      <td>16.340858</td>\n      <td>0.355271</td>\n      <td>0.007718</td>\n      <td>-0.153907</td>\n      <td>-1.130592</td>\n      <td>...</td>\n      <td>17.803600</td>\n      <td>1.762207</td>\n      <td>15.181189</td>\n      <td>130.784027</td>\n      <td>1.126688e+03</td>\n      <td>12.945052</td>\n      <td>111.519989</td>\n      <td>9.607307e+02</td>\n      <td>8.276573e+03</td>\n      <td>7.130162e+04</td>\n    </tr>\n    <tr>\n      <th>1.71</th>\n      <th>1.71</th>\n      <td>1.0</td>\n      <td>-0.596326</td>\n      <td>-0.002742</td>\n      <td>0.335006</td>\n      <td>2.578177</td>\n      <td>23.412802</td>\n      <td>0.355605</td>\n      <td>0.001635</td>\n      <td>-0.199773</td>\n      <td>-1.537435</td>\n      <td>...</td>\n      <td>61.519466</td>\n      <td>5.741048</td>\n      <td>52.135292</td>\n      <td>473.448181</td>\n      <td>4.299452e+03</td>\n      <td>44.182579</td>\n      <td>401.228424</td>\n      <td>3.643614e+03</td>\n      <td>3.308818e+04</td>\n      <td>3.004786e+05</td>\n    </tr>\n  </tbody>\n</table>\n<p>10000 rows × 126 columns</p>\n</div>\n```\n:::\n:::\n\n\nWe then use another extremely popular machine learning Python package called `scikit-learn` to easily work with our regression models.\n\n#### Ordinary least squares\nFirst, let's apply ordinary least squares to see if the solution is clear:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nimport sklearn.linear_model as lm\nimport sklearn.metrics as met\n\ndef compute_ols_results(A,b):\n    ols = lm.LinearRegression()\n    ols.fit(A, b)\n    Rsquare = met.r2_score(ols.predict(A), b)\n    print(\"R^2: {}\".format(Rsquare))\n    ols_results = pd.DataFrame(\n        data=[ols.coef_],\n        columns=term_matrix.columns,\n        index=[\"Coefficients\"]\n    )\n    return ols_results\ncompute_ols_results(term_matrix, h_t)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR^2: 0.9987072399768019\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=17}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>1</th>\n      <th>h(x, t)</th>\n      <th>h_x(x, t)</th>\n      <th>h_xx(x, t)</th>\n      <th>h_xxx(x, t)</th>\n      <th>h_xxxx(x, t)</th>\n      <th>h(x, t)**2</th>\n      <th>h(x, t)*h_x(x, t)</th>\n      <th>h(x, t)*h_xx(x, t)</th>\n      <th>h(x, t)*h_xxx(x, t)</th>\n      <th>...</th>\n      <th>h_xx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**3</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**2*h_xxxx(x, t)</th>\n      <th>h_xx(x, t)*h_xxx(x, t)*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxx(x, t)**4</th>\n      <th>h_xxx(x, t)**3*h_xxxx(x, t)</th>\n      <th>h_xxx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xxx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxxx(x, t)**4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>7.305386e-07</td>\n      <td>-0.000263</td>\n      <td>0.007865</td>\n      <td>0.00078</td>\n      <td>0.020306</td>\n      <td>0.000558</td>\n      <td>-0.000865</td>\n      <td>0.001602</td>\n      <td>0.003387</td>\n      <td>-0.003978</td>\n      <td>...</td>\n      <td>1.934960e-10</td>\n      <td>-9.703247e-10</td>\n      <td>-5.762052e-10</td>\n      <td>2.650240e-11</td>\n      <td>1.596587e-13</td>\n      <td>7.131852e-11</td>\n      <td>-6.073799e-12</td>\n      <td>-4.703859e-13</td>\n      <td>2.591677e-14</td>\n      <td>-1.654493e-16</td>\n    </tr>\n  </tbody>\n</table>\n<p>1 rows × 126 columns</p>\n</div>\n```\n:::\n:::\n\n\nAlthough the $R^2$ value implies that we have successful explained the variance in $h_t$ by linearly combining our term library, it is unclear which of all the terms most contributes to the time evolution from their coefficients.\n\n#### Lasso\nNow, let's add some regularization to try to remove some terms with the Lasso regression:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ndef compute_lasso_results(A,b,lamb):\n    lasso = lm.Lasso(lamb)\n    lasso.fit(A,b)\n    lasso_results = pd.DataFrame(\n        data=[lasso.coef_[lasso.coef_ != 0]],\n        columns=term_matrix.columns[lasso.coef_ != 0],\n        index=[\"Coefficients\"]\n    )\n    return lasso_results\ncompute_lasso_results(term_matrix,h_t,30)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/home/connor/mambaforge/envs/website/lib/python3.9/site-packages/sklearn/linear_model/_coordinate_descent.py:648: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations, check the scale of the features or consider increasing regularisation. Duality gap: 1.736e+03, tolerance: 1.101e+01\n  model = cd_fast.enet_coordinate_descent(\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=18}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_x(x, t)*h_xxxx(x, t)</th>\n      <th>h_xx(x, t)*h_xxx(x, t)</th>\n      <th>h_xx(x, t)*h_xxxx(x, t)</th>\n      <th>h_xxx(x, t)**2</th>\n      <th>h_xxx(x, t)*h_xxxx(x, t)</th>\n      <th>h_xxxx(x, t)**2</th>\n      <th>h(x, t)*h_x(x, t)*h_xxxx(x, t)</th>\n      <th>h(x, t)*h_xx(x, t)*h_xxxx(x, t)</th>\n      <th>h(x, t)*h_xxx(x, t)**2</th>\n      <th>h(x, t)*h_xxx(x, t)*h_xxxx(x, t)</th>\n      <th>...</th>\n      <th>h_xx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**3</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**2*h_xxxx(x, t)</th>\n      <th>h_xx(x, t)*h_xxx(x, t)*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxx(x, t)**4</th>\n      <th>h_xxx(x, t)**3*h_xxxx(x, t)</th>\n      <th>h_xxx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xxx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxxx(x, t)**4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>-0.000019</td>\n      <td>0.000042</td>\n      <td>0.000006</td>\n      <td>-0.000016</td>\n      <td>0.000005</td>\n      <td>-9.063636e-08</td>\n      <td>0.000033</td>\n      <td>-0.000011</td>\n      <td>-0.000004</td>\n      <td>-0.000003</td>\n      <td>...</td>\n      <td>2.762180e-11</td>\n      <td>7.853975e-10</td>\n      <td>-2.607652e-10</td>\n      <td>4.844794e-12</td>\n      <td>-2.047032e-13</td>\n      <td>-2.796429e-11</td>\n      <td>7.585219e-12</td>\n      <td>-3.492170e-13</td>\n      <td>1.942534e-14</td>\n      <td>-4.624859e-16</td>\n    </tr>\n  </tbody>\n</table>\n<p>1 rows × 86 columns</p>\n</div>\n```\n:::\n:::\n\n\nNow this at least removed some of the terms, but it also removed the term we know is correct!\nIt's somewhat hard to interpret exactly what this means.\nA convenient analysis using the Lasso method is to perform a \"lasso path\" in which we steadily decrease the regularization $\\lambda$ to add more and more terms and pay attention to the order with which they are added:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndef compute_lasso_path_results(A,b):\n    lambs, coef_path, _ = lm.lasso_path(A, b, alphas=[1000,200,100,10,2])\n    for i in range(coef_path.shape[1]):\n        print(\"lambda = {}\".format(lambs[i]))\n        temp_results = pd.DataFrame(\n            data=[coef_path[:,i][coef_path[:,i] != 0]],\n            columns=term_matrix.columns[coef_path[:,i] != 0],\n            index=[\"Coefficients\"]\n        )\n        display(temp_results)\ncompute_lasso_path_results(term_matrix,h_t)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nlambda = 1000\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n/home/connor/mambaforge/envs/website/lib/python3.9/site-packages/sklearn/linear_model/_coordinate_descent.py:634: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations. Duality gap: 6479.129693739391, tolerance: 11.011605073535403\n  model = cd_fast.enet_coordinate_descent_gram(\n/home/connor/mambaforge/envs/website/lib/python3.9/site-packages/sklearn/linear_model/_coordinate_descent.py:634: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations. Duality gap: 4239.991695254213, tolerance: 11.011605073535403\n  model = cd_fast.enet_coordinate_descent_gram(\n/home/connor/mambaforge/envs/website/lib/python3.9/site-packages/sklearn/linear_model/_coordinate_descent.py:634: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations. Duality gap: 3002.8945381092335, tolerance: 11.011605073535403\n  model = cd_fast.enet_coordinate_descent_gram(\n/home/connor/mambaforge/envs/website/lib/python3.9/site-packages/sklearn/linear_model/_coordinate_descent.py:634: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations. Duality gap: 1179.975834201264, tolerance: 11.011605073535403\n  model = cd_fast.enet_coordinate_descent_gram(\n/home/connor/mambaforge/envs/website/lib/python3.9/site-packages/sklearn/linear_model/_coordinate_descent.py:634: ConvergenceWarning: Objective did not converge. You might want to increase the number of iterations. Duality gap: 654.8432797880382, tolerance: 11.011605073535403\n  model = cd_fast.enet_coordinate_descent_gram(\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_xxx(x, t)*h_xxxx(x, t)</th>\n      <th>h_xxxx(x, t)**2</th>\n      <th>h(x, t)*h_xxx(x, t)*h_xxxx(x, t)</th>\n      <th>h(x, t)*h_xxxx(x, t)**2</th>\n      <th>h_x(x, t)**2*h_xxxx(x, t)</th>\n      <th>h_x(x, t)*h_xx(x, t)*h_xxxx(x, t)</th>\n      <th>h_x(x, t)*h_xxx(x, t)**2</th>\n      <th>h_x(x, t)*h_xxx(x, t)*h_xxxx(x, t)</th>\n      <th>h_x(x, t)*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)**2*h_xxx(x, t)</th>\n      <th>...</th>\n      <th>h_xx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**3</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**2*h_xxxx(x, t)</th>\n      <th>h_xx(x, t)*h_xxx(x, t)*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxx(x, t)**4</th>\n      <th>h_xxx(x, t)**3*h_xxxx(x, t)</th>\n      <th>h_xxx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xxx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxxx(x, t)**4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>0.000004</td>\n      <td>-1.358431e-07</td>\n      <td>-0.000003</td>\n      <td>1.734877e-07</td>\n      <td>-0.000024</td>\n      <td>-0.000018</td>\n      <td>0.000018</td>\n      <td>1.798373e-07</td>\n      <td>2.194965e-08</td>\n      <td>0.00002</td>\n      <td>...</td>\n      <td>1.755277e-12</td>\n      <td>5.409176e-09</td>\n      <td>-4.538993e-10</td>\n      <td>-1.582512e-11</td>\n      <td>-5.175585e-13</td>\n      <td>-1.599987e-10</td>\n      <td>1.446256e-11</td>\n      <td>-1.393073e-12</td>\n      <td>5.006291e-15</td>\n      <td>-1.081716e-15</td>\n    </tr>\n  </tbody>\n</table>\n<p>1 rows × 65 columns</p>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nlambda = 200\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_xx(x, t)*h_xxxx(x, t)</th>\n      <th>h_xxx(x, t)*h_xxxx(x, t)</th>\n      <th>h_xxxx(x, t)**2</th>\n      <th>h(x, t)*h_xxx(x, t)**2</th>\n      <th>h(x, t)*h_xxx(x, t)*h_xxxx(x, t)</th>\n      <th>h(x, t)*h_xxxx(x, t)**2</th>\n      <th>h_x(x, t)**2*h_xxxx(x, t)</th>\n      <th>h_x(x, t)*h_xx(x, t)**2</th>\n      <th>h_x(x, t)*h_xx(x, t)*h_xxx(x, t)</th>\n      <th>h_x(x, t)*h_xx(x, t)*h_xxxx(x, t)</th>\n      <th>...</th>\n      <th>h_xx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**3</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**2*h_xxxx(x, t)</th>\n      <th>h_xx(x, t)*h_xxx(x, t)*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxx(x, t)**4</th>\n      <th>h_xxx(x, t)**3*h_xxxx(x, t)</th>\n      <th>h_xxx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xxx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxxx(x, t)**4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>-0.000006</td>\n      <td>0.000006</td>\n      <td>-7.521095e-08</td>\n      <td>-0.00002</td>\n      <td>-0.000005</td>\n      <td>1.823142e-07</td>\n      <td>-0.000026</td>\n      <td>0.000536</td>\n      <td>0.000015</td>\n      <td>-0.000011</td>\n      <td>...</td>\n      <td>-2.414194e-11</td>\n      <td>5.320476e-09</td>\n      <td>-4.616117e-10</td>\n      <td>-1.611757e-11</td>\n      <td>-6.934056e-13</td>\n      <td>-1.620881e-10</td>\n      <td>1.653062e-11</td>\n      <td>-8.339717e-13</td>\n      <td>-2.720482e-15</td>\n      <td>-1.134801e-15</td>\n    </tr>\n  </tbody>\n</table>\n<p>1 rows × 73 columns</p>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nlambda = 100\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_xxx(x, t)**2</th>\n      <th>h_xxx(x, t)*h_xxxx(x, t)</th>\n      <th>h_xxxx(x, t)**2</th>\n      <th>h(x, t)*h_xxx(x, t)**2</th>\n      <th>h(x, t)*h_xxx(x, t)*h_xxxx(x, t)</th>\n      <th>h(x, t)*h_xxxx(x, t)**2</th>\n      <th>h_x(x, t)**2*h_xxxx(x, t)</th>\n      <th>h_x(x, t)*h_xx(x, t)**2</th>\n      <th>h_x(x, t)*h_xx(x, t)*h_xxx(x, t)</th>\n      <th>h_x(x, t)*h_xx(x, t)*h_xxxx(x, t)</th>\n      <th>...</th>\n      <th>h_xx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**3</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**2*h_xxxx(x, t)</th>\n      <th>h_xx(x, t)*h_xxx(x, t)*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxx(x, t)**4</th>\n      <th>h_xxx(x, t)**3*h_xxxx(x, t)</th>\n      <th>h_xxx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xxx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxxx(x, t)**4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>-0.000002</td>\n      <td>0.000008</td>\n      <td>-8.488413e-08</td>\n      <td>-0.000036</td>\n      <td>-0.000005</td>\n      <td>2.101204e-07</td>\n      <td>-0.000021</td>\n      <td>0.000994</td>\n      <td>0.000005</td>\n      <td>-0.000006</td>\n      <td>...</td>\n      <td>-4.268632e-11</td>\n      <td>5.269517e-09</td>\n      <td>-4.910490e-10</td>\n      <td>-1.314523e-11</td>\n      <td>-7.742993e-13</td>\n      <td>-1.331652e-10</td>\n      <td>2.042833e-11</td>\n      <td>-5.987478e-13</td>\n      <td>2.408342e-15</td>\n      <td>-1.135245e-15</td>\n    </tr>\n  </tbody>\n</table>\n<p>1 rows × 74 columns</p>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nlambda = 10\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_x(x, t)*h_xxxx(x, t)</th>\n      <th>h_xx(x, t)*h_xxxx(x, t)</th>\n      <th>h_xxx(x, t)**2</th>\n      <th>h_xxx(x, t)*h_xxxx(x, t)</th>\n      <th>h_xxxx(x, t)**2</th>\n      <th>h(x, t)*h_xx(x, t)*h_xxx(x, t)</th>\n      <th>h(x, t)*h_xx(x, t)*h_xxxx(x, t)</th>\n      <th>h(x, t)*h_xxx(x, t)**2</th>\n      <th>h(x, t)*h_xxx(x, t)*h_xxxx(x, t)</th>\n      <th>h(x, t)*h_xxxx(x, t)**2</th>\n      <th>...</th>\n      <th>h_xx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**3</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**2*h_xxxx(x, t)</th>\n      <th>h_xx(x, t)*h_xxx(x, t)*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxx(x, t)**4</th>\n      <th>h_xxx(x, t)**3*h_xxxx(x, t)</th>\n      <th>h_xxx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xxx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxxx(x, t)**4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>-0.000078</td>\n      <td>0.000022</td>\n      <td>-0.00003</td>\n      <td>0.000009</td>\n      <td>-3.621464e-08</td>\n      <td>-0.000142</td>\n      <td>0.000003</td>\n      <td>-0.000044</td>\n      <td>-0.000006</td>\n      <td>2.333756e-07</td>\n      <td>...</td>\n      <td>-5.158209e-11</td>\n      <td>5.223241e-09</td>\n      <td>-5.293248e-10</td>\n      <td>-6.898464e-12</td>\n      <td>-7.832659e-13</td>\n      <td>-9.675606e-11</td>\n      <td>2.194779e-11</td>\n      <td>-3.257965e-13</td>\n      <td>9.419454e-15</td>\n      <td>-1.060554e-15</td>\n    </tr>\n  </tbody>\n</table>\n<p>1 rows × 87 columns</p>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nlambda = 2\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h(x, t)*h_xxxx(x, t)</th>\n      <th>h_x(x, t)*h_xxx(x, t)</th>\n      <th>h_x(x, t)*h_xxxx(x, t)</th>\n      <th>h_xx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxx(x, t)</th>\n      <th>h_xx(x, t)*h_xxxx(x, t)</th>\n      <th>h_xxx(x, t)**2</th>\n      <th>h_xxx(x, t)*h_xxxx(x, t)</th>\n      <th>h_xxxx(x, t)**2</th>\n      <th>h(x, t)**2*h_xxxx(x, t)</th>\n      <th>...</th>\n      <th>h_xx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**3</th>\n      <th>h_xx(x, t)*h_xxx(x, t)**2*h_xxxx(x, t)</th>\n      <th>h_xx(x, t)*h_xxx(x, t)*h_xxxx(x, t)**2</th>\n      <th>h_xx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxx(x, t)**4</th>\n      <th>h_xxx(x, t)**3*h_xxxx(x, t)</th>\n      <th>h_xxx(x, t)**2*h_xxxx(x, t)**2</th>\n      <th>h_xxx(x, t)*h_xxxx(x, t)**3</th>\n      <th>h_xxxx(x, t)**4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>-0.000016</td>\n      <td>0.000541</td>\n      <td>-0.00018</td>\n      <td>-0.000066</td>\n      <td>0.000133</td>\n      <td>0.000032</td>\n      <td>-0.000033</td>\n      <td>0.000008</td>\n      <td>-1.995623e-08</td>\n      <td>-0.000084</td>\n      <td>...</td>\n      <td>-6.687787e-11</td>\n      <td>4.931579e-09</td>\n      <td>-4.735351e-10</td>\n      <td>-7.393932e-12</td>\n      <td>-6.988554e-13</td>\n      <td>-7.077843e-11</td>\n      <td>1.972181e-11</td>\n      <td>-3.251633e-14</td>\n      <td>7.291433e-15</td>\n      <td>-8.183021e-16</td>\n    </tr>\n  </tbody>\n</table>\n<p>1 rows × 97 columns</p>\n</div>\n```\n:::\n:::\n\n\nAgain, although this gives us a sense of sparsity, it also doesn't seem to capture the solution well.\n\n#### Greedy forward selection\nLet's instead try a greedy method for our system that will inform which terms should be included.\nTo do so, we will use a generic `scikit-learn` interface called `SequentialFeatureSelector` as well as the $R^2$ coefficient of determination `r2_score` to select terms one by one that best \"explain the variance\" in the time evolution $h_t(x,t)$.\nAs the terms are selected, we will compute the coefficients of the small libraries via ordinary least squares:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\nimport sklearn.feature_selection as fs\n\ndef forward_r2_select(A,b,num_terms=4):\n    for i in range(1,num_terms+1):\n        sfs = fs.SequentialFeatureSelector(\n            lm.LinearRegression(),\n            n_features_to_select=i,\n            scoring=met.make_scorer(met.r2_score)\n        )\n        new_A = sfs.fit_transform(A,b)\n        new_ols = sfs.estimator\n        new_ols.fit(new_A,b)\n        Rsquare = met.r2_score(new_ols.predict(new_A),b)\n        feat_names = sfs.get_feature_names_out(A.columns)\n        print(\"R^2: {}\".format(Rsquare))\n        temp_results = pd.DataFrame(\n            data=[new_ols.coef_],\n            columns=feat_names,\n            index=[\"Coefficients\"]\n        )\n        display(temp_results)\n\nforward_r2_select(term_matrix, h_t)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR^2: 0.9999009929293052\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_x(x, t)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>0.9948</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR^2: 0.9999137793593055\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_x(x, t)</th>\n      <th>h(x, t)*h_x(x, t)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>1.000245</td>\n      <td>-0.004588</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR^2: 0.9999166091843339\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_x(x, t)</th>\n      <th>h(x, t)*h_x(x, t)</th>\n      <th>h_x(x, t)**2*h_xxx(x, t)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>1.000994</td>\n      <td>-0.003494</td>\n      <td>0.000001</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR^2: 0.9999179601805686\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_x(x, t)</th>\n      <th>h(x, t)*h_x(x, t)</th>\n      <th>h_x(x, t)**2*h_xxx(x, t)</th>\n      <th>h_x(x, t)*h_xx(x, t)*h_xxxx(x, t)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>1.001286</td>\n      <td>-0.003129</td>\n      <td>0.000001</td>\n      <td>1.281114e-08</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThis seems to easily pick up that the only term needed to completely resolve the time evolution is $h_x(x,t)$!\n\n## Application to noisy simulated wave data {#sec-noisy}\nIn a real system, we could not expect to immediately have data as smooth as that we used in @sec-simulated.\nHowever, the procedure is unchanged.\nThe only challenge will be fitting the neural network to our data.\nLet's add some noise to the data:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nx,t,noisy_h = load_data(\"simple_wave.npz\",.2)\nanimation2 = animate_data(x,t,[noisy_h], [\"h noisy\"])\nanimation2.save(\"noisy_h.gif\")\nplt.close()\n```\n:::\n\n\n![](noisy_h.gif)\n\nGiven our data is now noisy, we may want to implement a train-validation-test method for fitting.\nSimply put, this means that we will hold out a portion of our data from the training procedure.\nPart of this held-back data (validation set) will be used to validate that our model can generalize to other points during training.\nThe other part of the held-back data (test set) will be used as a final check on how well the model extrapolates out of the training data.\n\n<!-- TODO: Function to split data into train,valid,test sets (scikit-learn?) -->\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nimport sklearn.model_selection as ms\n\nX,T = jnp.meshgrid(x,t)\nxt_noisy = np.vstack((X.flatten(),T.flatten())).T\nh_noisy = noisy_h.flatten()\nxt_train, xt_test, h_train, h_test = ms.train_test_split(xt_noisy,h_noisy,test_size=.1,train_size=.9)\nxt_train, xt_valid, h_train, h_valid = ms.train_test_split(xt_train,h_train,test_size=.1,train_size=.9)\n\ntrain_data = batch_data(xt_train[:,0], xt_train[:,1], h_train, 1000)\nvalid_data = batch_data(xt_valid[:,0], xt_valid[:,1], h_valid, 1000)\ntest_data = batch_data(xt_test[:,0], xt_test[:,1], h_test, 1000)\n```\n:::\n\n\nNow, we apply our previous model construction and training:\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\n# Initialize model\nrng1,rng2 = jax.random.split(jax.random.PRNGKey(42))\nrandom_data = jax.random.normal(rng1,(2,))\nmodel2 = MyNet()\nparams2 = model2.init(rng2,random_data)\n\n# Loss function\n@jax.jit\ndef mse(params,input,targets):\n    def squared_error(x,y):\n        pred = model2.apply(params,x)\n        return jnp.mean((y - pred)**2)\n    return jnp.mean(jax.vmap(squared_error)(input,targets),axis=0)\nloss_grad_fn = jax.value_and_grad(mse)\n\n# Optimizer\nlearning_rate = 1e-2\ntx = optax.adam(learning_rate)\nopt_state = tx.init(params2)\n\n# Training (adjusted to use our validation data\nepochs = 1200\nfor i in range(epochs):\n    xt_batch = train_data[i%len(train_data)][0]\n    h_batch = train_data[i%len(train_data)][1]\n    loss_val, grads = loss_grad_fn(params2, xt_batch, h_batch)\n    updates, opt_state = tx.update(grads, opt_state)\n    params2 = optax.apply_updates(params2, updates)\n    if i % 100 == 0:\n        train_loss = mse(params2,xt_train,h_train)\n        valid_loss = mse(params2,xt_valid,h_valid)\n        print(\"Step {}\".format(i))\n        print(\"Training loss: {}\".format(train_loss))\n        print(\"Validation loss: {}\".format(valid_loss))\n        print()\ntest_loss = mse(params2,xt_test,h_test)\nprint(\"Test loss after training: {}\".format(test_loss))\n\nhhat = model2.apply(params2,xt_points).reshape(X.shape)\ndiff = np.sqrt((noisy_h - hhat)**2)\nanimation3 = animate_data(x,t,[noisy_h,hhat,diff],[\"$h$\",\"$\\hat{h}$\",\"$L^2$ error\"])\nanimation3.save(\"noisy_h_compare.gif\")\nplt.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 0\nTraining loss: 1.088370442390442\nValidation loss: 1.02261221408844\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 100\nTraining loss: 0.23923365771770477\nValidation loss: 0.23434635996818542\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 200\nTraining loss: 0.14842058718204498\nValidation loss: 0.1465066522359848\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 300\nTraining loss: 0.10403300821781158\nValidation loss: 0.10247919708490372\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 400\nTraining loss: 0.05689145252108574\nValidation loss: 0.05504126846790314\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 500\nTraining loss: 0.0434672087430954\nValidation loss: 0.04231194779276848\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 600\nTraining loss: 0.04024023562669754\nValidation loss: 0.04016528278589249\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 700\nTraining loss: 0.03964407369494438\nValidation loss: 0.03996383771300316\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 800\nTraining loss: 0.04071784019470215\nValidation loss: 0.04050168767571449\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 900\nTraining loss: 0.04218659549951553\nValidation loss: 0.04138324782252312\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 1000\nTraining loss: 0.04140334948897362\nValidation loss: 0.040608298033475876\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 1100\nTraining loss: 0.03981845825910568\nValidation loss: 0.03926330804824829\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTest loss after training: 0.041989926248788834\n```\n:::\n:::\n\n\nThe resulting fit can be seen in the following video:\n\n![](noisy_h_compare.gif)\n\nLooks pretty good all things considered!\nFinally, we construct the terms and check the results after forward selection:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\ndef model_for_diff(x,t):\n    new_x = jnp.array([x,t])\n    return model2.apply(params2, new_x)[0]\n\n# Construct terms numerically\ndiff_term_values = {}\nfor i in range(max_diff_order+1):\n    diff_func = model_for_diff\n    # Iteratively apply derivatives\n    for _ in range(i):\n        diff_func = jax.grad(diff_func, 0)\n    def unpack_diff_func(x):\n        new_x,new_t = x\n        return diff_func(new_x,new_t)\n    diff_term_values[diff_terms[i]] = np.array(jax.lax.map(unpack_diff_func, xt_points))\nterm_values = construct_terms(diff_term_values)\n\ndef unpack_diff_func(x):\n    new_x,new_t = x\n    return jax.grad(model_for_diff,1)(new_x,new_t)\n\nh_t_term = sp.Function(\"h_t\")(x_sym,t_sym)\nh_t = -np.array(jax.lax.map(unpack_diff_func, xt_points))\n\n# Forward selection\nterm_matrix = pd.DataFrame(term_values,index=pd.MultiIndex.from_arrays(np.round(np.array(xt_points),2).T, names=(\"x\",\"t\")))\nforward_r2_select(term_matrix, h_t)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR^2: 0.999362804080897\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_x(x, t)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>0.992748</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR^2: 0.999362804080897\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>1</th>\n      <th>h_x(x, t)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>0.0</td>\n      <td>0.992748</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR^2: 0.9993632440081892\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>1</th>\n      <th>h_x(x, t)</th>\n      <th>h_xx(x, t)**3*h_xxx(x, t)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>0.0</td>\n      <td>0.992891</td>\n      <td>-3.769122e-10</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR^2: 0.9993694078480256\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>1</th>\n      <th>h_x(x, t)</th>\n      <th>h_xx(x, t)**2*h_xxx(x, t)</th>\n      <th>h_xx(x, t)**3*h_xxx(x, t)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>0.0</td>\n      <td>0.993818</td>\n      <td>1.494332e-07</td>\n      <td>2.535925e-09</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nBoom!\nLanded right on the money.\nThis is a simple example with a straightforward answer, but example holds to show the overall procedure for handling data with additive noise (multiplicative noise, which is more structural, would be an altogether different challenge).\n\n## Application to extracted wave data {#sec-extracted}\nNow, applying this procedure to real data is as simple as replacing our original dataset with an experimental dataset.\nHowever, the extraction process has a strong influence on the quality of the data that we will be using, so it deserves to be treated with some detail.\n\n### Image data extraction\nThe original video we will be using can be found on YouTube [here](https://www.youtube.com/watch?v=wEbYELtGZwI).\n\n![](youtube_video.mp4)\n\nWe can load this video into individual image frames via:\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nimport skimage as img\nimport imageio.v3 as iio\n\nraw_frames = []\ncut = (160,200)\nfor i in range(200,232):\n    frame = iio.imread(\"youtube_video.mp4\",plugin=\"pyav\",index=i)\n\n    # Cut the image to focus only on the wave portion\n    raw_frame = frame[cut[0]:cut[1],:,:]\n    raw_frames.append(raw_frame)\nraw_frames = np.array(raw_frames)\nplt.figure(figsize=(8,1))\nplt.imshow(raw_frames[16])\nplt.axis(False); plt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](workshop3_discovery_files/figure-html/cell-26-output-1.png){width=614 height=72}\n:::\n:::\n\n\nWe then need to remove the background and isolate the wave portion of the image, which is facilitated by the green color of the water in this video:\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\nframes = []\nfor i in range(len(raw_frames)):\n    frame = raw_frames[i]\n\n    # Find where the image is more green than red or blue and very bright green\n    mean_green = np.mean(frame[:,:,1])\n    std_green = np.std(frame[:,:,1])\n    frame = (frame[:,:,1] > frame[:,:,0]) & (frame[:,:,1] > frame[:,:,2]) & (frame[:,:,1] > mean_green+std_green)\n    frames.append(frame)\nframes = np.array(frames)\nplt.figure(figsize=(8,1))\nplt.imshow(frames[16],cmap=\"gray\")\nplt.axis(False); plt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](workshop3_discovery_files/figure-html/cell-27-output-1.png){width=614 height=72}\n:::\n:::\n\n\nBy averaging these pixels across all vertical pixels in the image, we can get a rough wave outline:\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\nheights = []\nfor i in range(len(frames)):\n    frame = frames[i]\n    \n    # Approximate wave height by averaging y-locations of bright green areas\n    height = np.zeros(frame.shape[1])\n    for j in range(frame.shape[1]):\n        height[j] = np.mean(np.where(frame[:,j] == 1)[0])\n    heights.append(height)\nheights = np.array(heights)\nbase = heights[16, 0]\n\nplt.figure(figsize=(8,1))\nplt.imshow(frames[16],cmap=\"gray\")\nline = plt.plot(heights[16], color=\"red\",lw=3)[0]\nline2 = plt.plot([0,heights.shape[1]], [31,31], color=\"orange\", ls=\"--\")[0]\nplt.axis(False); plt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](workshop3_discovery_files/figure-html/cell-28-output-1.png){width=614 height=70}\n:::\n:::\n\n\nFinally, we can note that the video is not quite level to the wave surface, so we can use a linear adjustment to align the water boundary heights at the middle of the video:\n\n<!-- TODO: Show wave baseline adjustment. -->\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\n# Adjust images and heights for an un-leveled camera\nim_width = len(heights[16])\nslope = (heights[16][-1] - heights[16][0]) / im_width\nfor i in range(len(heights)):\n    frame = frames[i]\n    height = heights[i]\n\n    # Adjust\n    for j in range(len(height)):\n        shift = int(slope*(im_width-j))\n        # Move frame pixels per column\n        frame[:,j] = np.roll(frame[:,j], shift)\n        # Move height of wave\n        height[j] += shift\n    frames[i] = frame\n    heights[i] = height\n\nframes = np.array(frames)\nraw_frames = np.array(raw_frames)\nheights = np.array(heights)\n\nfig = plt.figure(figsize=(8,1))\nim = plt.imshow(frames[0],cmap=\"gray\")\nline = plt.plot(heights[0], color=\"red\",lw=3)[0]\nline2 = plt.plot([0,heights.shape[1]], [31,31], color=\"orange\", ls=\"--\")[0]\nplt.axis(False);\n\ndef animation_function(i):\n    im.set_array(frames[i])\n    line.set_ydata(heights[i])\n    return [im,line,line2]\n\nwave_animation = anim.FuncAnimation(fig, animation_function, frames=range(len(frames)), blit=True)\nwave_animation.save(\"extracted_wave.gif\")\nplt.close()\n```\n:::\n\n\n![](extracted_wave.gif)\n\nWe can now save this data to be used with our previous procedure:\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\n# Video portion is about 2 seconds long\ntimes = np.linspace(0,2,len(heights))\n# No given space scale\nx_domain = np.arange(len(heights[0]))\nnp.save(\"video_wave_images.npy\",raw_frames)\nnp.savez(\"video_wave_heights.npz\",h=heights,x=x_domain,t=times)\n```\n:::\n\n\n### Using our experimental dataset\nUsing the same methods as listed in @sec-noisy, we can discover an equation for this particular dataset:\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nx,t,ext_h = load_data(\"video_wave_heights.npz\")\n# Flip image wave to be more familiar\next_h = -ext_h\nanimation2 = animate_data(x,t,[ext_h], [\"extracted h\"])\nanimation2.save(\"extracted_h.gif\")\nplt.close()\n```\n:::\n\n\n![](extracted_h.gif)\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\n# Splitting data\nX,T = jnp.meshgrid(x,t)\nxt_ext = np.vstack((X.flatten(),T.flatten())).T\nh_ext = ext_h.flatten()\nxt_train, xt_test, h_train, h_test = ms.train_test_split(xt_ext,h_ext,test_size=.1,train_size=.9)\nxt_train, xt_valid, h_train, h_valid = ms.train_test_split(xt_train,h_train,test_size=.1,train_size=.9)\n\ntrain_data = batch_data(xt_train[:,0], xt_train[:,1], h_train, 1000)\nvalid_data = batch_data(xt_valid[:,0], xt_valid[:,1], h_valid, 1000)\ntest_data = batch_data(xt_test[:,0], xt_test[:,1], h_test, 1000)\n\n# Initialize model\nrng1,rng2 = jax.random.split(jax.random.PRNGKey(42))\nrandom_data = jax.random.normal(rng1,(2,))\nmodel3 = MyNet()\nparams3 = model3.init(rng2,random_data)\n\n# Loss function\n@jax.jit\ndef mse(params,input,targets):\n    def squared_error(x,y):\n        pred = model3.apply(params,x)\n        return jnp.mean((y - pred)**2)\n    return jnp.mean(jax.vmap(squared_error)(input,targets),axis=0)\nloss_grad_fn = jax.value_and_grad(mse)\n\n# Optimizer\nlearning_rate = 1e-2\ntx = optax.adam(learning_rate)\nopt_state = tx.init(params3)\n\n# Training (adjusted to use our validation data\nepochs = 1200\nfor i in range(epochs):\n    xt_batch = train_data[i%len(train_data)][0]\n    h_batch = train_data[i%len(train_data)][1]\n    loss_val, grads = loss_grad_fn(params3, xt_batch, h_batch)\n    updates, opt_state = tx.update(grads, opt_state)\n    params3 = optax.apply_updates(params3, updates)\n    if i % 100 == 0:\n        train_loss = mse(params3,xt_train,h_train)\n        valid_loss = mse(params3,xt_valid,h_valid)\n        print(\"Step {}\".format(i))\n        print(\"Training loss: {}\".format(train_loss))\n        print(\"Validation loss: {}\".format(valid_loss))\n        print()\ntest_loss = mse(params3,xt_test,h_test)\nprint(\"Test loss after training: {}\".format(test_loss))\n\nhhat = model3.apply(params3,xt_ext).reshape(X.shape)\ndiff = np.sqrt((ext_h - hhat)**2)\nanimation3 = animate_data(x,t,[ext_h,hhat,diff],[\"$extracted h$\",\"$\\hat{h}$\",\"$L^2$ error\"])\nanimation3.save(\"ext_h_compare.gif\")\nplt.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 0\nTraining loss: 1.0295377969741821\nValidation loss: 1.1295952796936035\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 100\nTraining loss: 0.01888686791062355\nValidation loss: 0.018603166565299034\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 200\nTraining loss: 0.015895208343863487\nValidation loss: 0.015097544528543949\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 300\nTraining loss: 0.015159177593886852\nValidation loss: 0.014175577089190483\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 400\nTraining loss: 0.014689643867313862\nValidation loss: 0.014466807246208191\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 500\nTraining loss: 0.013770081102848053\nValidation loss: 0.012997274287045002\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 600\nTraining loss: 0.013605344109237194\nValidation loss: 0.013018128462135792\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 700\nTraining loss: 0.012960381805896759\nValidation loss: 0.01260566245764494\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 800\nTraining loss: 0.01275940053164959\nValidation loss: 0.012205351144075394\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 900\nTraining loss: 0.012392761185765266\nValidation loss: 0.011866135522723198\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 1000\nTraining loss: 0.011908532120287418\nValidation loss: 0.011681348085403442\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nStep 1100\nTraining loss: 0.011160660535097122\nValidation loss: 0.010744725354015827\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nTest loss after training: 0.01099537406116724\n```\n:::\n:::\n\n\n![](ext_h_compare.gif)\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\ndef model_for_diff(x,t):\n    new_x = jnp.array([x,t])\n    return model3.apply(params3, new_x)[0]\n\n# Construct terms numerically\ndiff_term_values = {}\nfor i in range(max_diff_order+1):\n    diff_func = model_for_diff\n    # Iteratively apply derivatives\n    for _ in range(i):\n        diff_func = jax.grad(diff_func, 0)\n    def unpack_diff_func(x):\n        new_x,new_t = x\n        return diff_func(new_x,new_t)\n    diff_term_values[diff_terms[i]] = np.array(jax.lax.map(unpack_diff_func, xt_ext))\nterm_values = construct_terms(diff_term_values)\n\ndef unpack_diff_func(x):\n    new_x,new_t = x\n    return jax.grad(model_for_diff,1)(new_x,new_t)\n\nh_t_term = sp.Function(\"h_t\")(x_sym,t_sym)\nh_t = -np.array(jax.lax.map(unpack_diff_func, xt_ext))\n\n# Forward selection\nterm_matrix = pd.DataFrame(term_values,index=pd.MultiIndex.from_arrays(np.round(np.array(xt_ext),2).T, names=(\"x\",\"t\")))\nforward_r2_select(term_matrix, h_t)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR^2: 0.986532203092632\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_x(x, t)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>-0.960688</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR^2: 0.9867193762911142\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_x(x, t)</th>\n      <th>h(x, t)*h_x(x, t)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>-0.938803</td>\n      <td>-0.016764</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR^2: 0.9876897491053909\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_x(x, t)</th>\n      <th>h(x, t)*h_x(x, t)</th>\n      <th>h(x, t)**2*h_x(x, t)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>-0.906299</td>\n      <td>-0.121123</td>\n      <td>0.044882</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nR^2: 0.9890521650070806\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>h_x(x, t)</th>\n      <th>h(x, t)*h_x(x, t)</th>\n      <th>h(x, t)**2*h_x(x, t)</th>\n      <th>h(x, t)**3*h_x(x, t)</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>Coefficients</th>\n      <td>-0.92115</td>\n      <td>-0.256145</td>\n      <td>0.242835</td>\n      <td>-0.06016</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nFeel free to play with the parameters of each step to try to change/improve the results we have seen here.\n\n",
    "supporting": [
      "workshop3_discovery_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n<script src=\"https://unpkg.com/@jupyter-widgets/html-manager@*/dist/embed-amd.js\" crossorigin=\"anonymous\"></script>\n"
      ],
      "include-after-body": [
        "<script type=application/vnd.jupyter.widget-state+json>\n{\"state\":{\"0aad832ae22649b2a428a149bf4a5578\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"HTMLModel\",\"state\":{\"_dom_classes\":[],\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"HTMLModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/controls\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"HTMLView\",\"description\":\"\",\"description_allow_html\":false,\"layout\":\"IPY_MODEL_48162aa7f8124247964ee021477d261d\",\"placeholder\":\"​\",\"style\":\"IPY_MODEL_77d0b5b7918d46469c5347ad9837a30e\",\"tabbable\":null,\"tooltip\":null,\"value\":\" 100/100 [00:01&lt;00:00, 73.35it/s]\"}},\"1827f7184483491eab642992211af638\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"HBoxModel\",\"state\":{\"_dom_classes\":[],\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"HBoxModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/controls\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"HBoxView\",\"box_style\":\"\",\"children\":[\"IPY_MODEL_98f2b9e3b04249f2881014b712d1101d\",\"IPY_MODEL_830f99d5ead44d21b965d8a163a602e6\",\"IPY_MODEL_0aad832ae22649b2a428a149bf4a5578\"],\"layout\":\"IPY_MODEL_189147f17f3946aba9116fe386b09c4c\",\"tabbable\":null,\"tooltip\":null}},\"189147f17f3946aba9116fe386b09c4c\":{\"model_module\":\"@jupyter-widgets/base\",\"model_module_version\":\"2.0.0\",\"model_name\":\"LayoutModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/base\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"LayoutModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"LayoutView\",\"align_content\":null,\"align_items\":null,\"align_self\":null,\"border_bottom\":null,\"border_left\":null,\"border_right\":null,\"border_top\":null,\"bottom\":null,\"display\":null,\"flex\":null,\"flex_flow\":null,\"grid_area\":null,\"grid_auto_columns\":null,\"grid_auto_flow\":null,\"grid_auto_rows\":null,\"grid_column\":null,\"grid_gap\":null,\"grid_row\":null,\"grid_template_areas\":null,\"grid_template_columns\":null,\"grid_template_rows\":null,\"height\":null,\"justify_content\":null,\"justify_items\":null,\"left\":null,\"margin\":null,\"max_height\":null,\"max_width\":null,\"min_height\":null,\"min_width\":null,\"object_fit\":null,\"object_position\":null,\"order\":null,\"overflow\":null,\"padding\":null,\"right\":null,\"top\":null,\"visibility\":null,\"width\":null}},\"442fa422e5fa4c7d9da84d9baa3c23ba\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"HTMLStyleModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"HTMLStyleModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"StyleView\",\"background\":null,\"description_width\":\"\",\"font_size\":null,\"text_color\":null}},\"48162aa7f8124247964ee021477d261d\":{\"model_module\":\"@jupyter-widgets/base\",\"model_module_version\":\"2.0.0\",\"model_name\":\"LayoutModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/base\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"LayoutModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"LayoutView\",\"align_content\":null,\"align_items\":null,\"align_self\":null,\"border_bottom\":null,\"border_left\":null,\"border_right\":null,\"border_top\":null,\"bottom\":null,\"display\":null,\"flex\":null,\"flex_flow\":null,\"grid_area\":null,\"grid_auto_columns\":null,\"grid_auto_flow\":null,\"grid_auto_rows\":null,\"grid_column\":null,\"grid_gap\":null,\"grid_row\":null,\"grid_template_areas\":null,\"grid_template_columns\":null,\"grid_template_rows\":null,\"height\":null,\"justify_content\":null,\"justify_items\":null,\"left\":null,\"margin\":null,\"max_height\":null,\"max_width\":null,\"min_height\":null,\"min_width\":null,\"object_fit\":null,\"object_position\":null,\"order\":null,\"overflow\":null,\"padding\":null,\"right\":null,\"top\":null,\"visibility\":null,\"width\":null}},\"77d0b5b7918d46469c5347ad9837a30e\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"HTMLStyleModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"HTMLStyleModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"StyleView\",\"background\":null,\"description_width\":\"\",\"font_size\":null,\"text_color\":null}},\"830f99d5ead44d21b965d8a163a602e6\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"FloatProgressModel\",\"state\":{\"_dom_classes\":[],\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"FloatProgressModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/controls\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"ProgressView\",\"bar_style\":\"success\",\"description\":\"\",\"description_allow_html\":false,\"layout\":\"IPY_MODEL_f43acbeaf4be4f1b815c0bf924deb5f0\",\"max\":100,\"min\":0,\"orientation\":\"horizontal\",\"style\":\"IPY_MODEL_9c32465af702412ba6f52fa09c3c28f5\",\"tabbable\":null,\"tooltip\":null,\"value\":100}},\"98f2b9e3b04249f2881014b712d1101d\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"HTMLModel\",\"state\":{\"_dom_classes\":[],\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"HTMLModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/controls\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"HTMLView\",\"description\":\"\",\"description_allow_html\":false,\"layout\":\"IPY_MODEL_c3a93fec9906404ea70c18fdef8b889e\",\"placeholder\":\"​\",\"style\":\"IPY_MODEL_442fa422e5fa4c7d9da84d9baa3c23ba\",\"tabbable\":null,\"tooltip\":null,\"value\":\"100%\"}},\"9c32465af702412ba6f52fa09c3c28f5\":{\"model_module\":\"@jupyter-widgets/controls\",\"model_module_version\":\"2.0.0\",\"model_name\":\"ProgressStyleModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/controls\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"ProgressStyleModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"StyleView\",\"bar_color\":null,\"description_width\":\"\"}},\"c3a93fec9906404ea70c18fdef8b889e\":{\"model_module\":\"@jupyter-widgets/base\",\"model_module_version\":\"2.0.0\",\"model_name\":\"LayoutModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/base\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"LayoutModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"LayoutView\",\"align_content\":null,\"align_items\":null,\"align_self\":null,\"border_bottom\":null,\"border_left\":null,\"border_right\":null,\"border_top\":null,\"bottom\":null,\"display\":null,\"flex\":null,\"flex_flow\":null,\"grid_area\":null,\"grid_auto_columns\":null,\"grid_auto_flow\":null,\"grid_auto_rows\":null,\"grid_column\":null,\"grid_gap\":null,\"grid_row\":null,\"grid_template_areas\":null,\"grid_template_columns\":null,\"grid_template_rows\":null,\"height\":null,\"justify_content\":null,\"justify_items\":null,\"left\":null,\"margin\":null,\"max_height\":null,\"max_width\":null,\"min_height\":null,\"min_width\":null,\"object_fit\":null,\"object_position\":null,\"order\":null,\"overflow\":null,\"padding\":null,\"right\":null,\"top\":null,\"visibility\":null,\"width\":null}},\"f43acbeaf4be4f1b815c0bf924deb5f0\":{\"model_module\":\"@jupyter-widgets/base\",\"model_module_version\":\"2.0.0\",\"model_name\":\"LayoutModel\",\"state\":{\"_model_module\":\"@jupyter-widgets/base\",\"_model_module_version\":\"2.0.0\",\"_model_name\":\"LayoutModel\",\"_view_count\":null,\"_view_module\":\"@jupyter-widgets/base\",\"_view_module_version\":\"2.0.0\",\"_view_name\":\"LayoutView\",\"align_content\":null,\"align_items\":null,\"align_self\":null,\"border_bottom\":null,\"border_left\":null,\"border_right\":null,\"border_top\":null,\"bottom\":null,\"display\":null,\"flex\":null,\"flex_flow\":null,\"grid_area\":null,\"grid_auto_columns\":null,\"grid_auto_flow\":null,\"grid_auto_rows\":null,\"grid_column\":null,\"grid_gap\":null,\"grid_row\":null,\"grid_template_areas\":null,\"grid_template_columns\":null,\"grid_template_rows\":null,\"height\":null,\"justify_content\":null,\"justify_items\":null,\"left\":null,\"margin\":null,\"max_height\":null,\"max_width\":null,\"min_height\":null,\"min_width\":null,\"object_fit\":null,\"object_position\":null,\"order\":null,\"overflow\":null,\"padding\":null,\"right\":null,\"top\":null,\"visibility\":null,\"width\":null}}},\"version_major\":2,\"version_minor\":0}\n</script>\n"
      ]
    }
  }
}