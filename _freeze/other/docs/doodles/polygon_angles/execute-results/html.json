{
  "hash": "14c4f21f7ed66ae874270815b48acece",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: The exterior angles of a polygon make a circle\nauthor: Connor Robertson\nengine: julia\nexecute:\n  daemon: true\ncategories: [Doodles]\n---\n\n\n\n\n## Overview\nI recently saw a [fun little GIF](https://gfycat.com/bluesecondblackwidowspider-geometry-math) from a weekly news email I get called the New Paper.\nIt shows a simple plot of the exterior angles of a few polygons.\nAs the polygons shrink, the exterior angles combine to eventually make a circle, which shows a simple graphical example of how the exterior angles of any polygon add to $2\\pi$.\n<!-- The GIF can be seen below: -->\n\n<!-- <div style='position:relative; padding-bottom:calc(100.00% + 44px)'><iframe src='https://gfycat.com/ifr/BlueSecondBlackwidowspider' frameborder='0' scrolling='no' width='100%' height='100%' style='position:absolute;top:0;left:0;' allowfullscreen></iframe></div> -->\n\n\nI thought I'd try to recreate this little GIF with my favorite plotting library `Makie.jl`.\n\n## Setting up\nBasically, we can start by getting the plots of each polygon set.\nWe can then animate the sides of the polygons shrinking.\n\nTo start we are going to need a `Figure` with 4 `axes`:\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nusing Pkg;\nPkg.activate(\".\");\nusing CairoMakie;\n```\n:::\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\nf = Figure(resolution=(800,800));\naxes = [\n  Axis(f[1,1]) Axis(f[1,2]);\n  Axis(f[2,1]) Axis(f[2,2])\n]\nfor ax in axes ax.limits=(-6,6,-6,6) end\n```\n:::\n\n\n\n\n\nWe can now list the vertices for each polygon:\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\npoly11 = [(-2.0,3.0),(3.0,-3.0),(-4.0,-2.0),(-2.0,3.0)];\npoly12 = [(-3.0,2.0),(1.0,1.0),(3.0,-2.0),(-4.0,-1.0),(-3.0,2.0)];\npoly21 = [(-1.0,3.0),(1.0,3.0),(3.0,-1.0),(1.0,-3.0),(-2.0,-2.0),(-3.0,1.0),(-1.0,3.0)];\npoly22 = [(-1.0,2.0),(1.0,2.0),(4.0,-1.0),(2.0,-3.0),(-4.0,-1.0),(-1.0,2.0)];\n```\n:::\n\n\n\n\n\nwhere `poly11` is the polygon in the 1st row and 1st column.\nPlotting these lines on each respective axis, we get:\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\nlines!(axes[1,1],poly11,color=:black);\nlines!(axes[1,2],poly12,color=:black);\nlines!(axes[2,1],poly21,color=:black);\nlines!(axes[2,2],poly22,color=:black);\npoly!(axes[1,1],poly11,transparency=true,color=RGBAf(1.0,0.6,0.0,0.2));\npoly!(axes[1,2],poly12,transparency=true,color=RGBAf(0.0,0.0,1.0,0.2));\npoly!(axes[2,1],poly21,transparency=true,color=RGBAf(0.5,0.0,0.5,0.2));\npoly!(axes[2,2],poly22,transparency=true,color=RGBAf(0.0,0.5,0.0,0.2));\ndisplay(f)\n```\n\n::: {.cell-output .cell-output-display}\n![](polygon_angles_files/figure-html/cell-5-output-1.svg){}\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nCairoMakie.Screen{PDF}\n```\n:::\n:::\n\n\n\n\n\nThese are obviously not exactly the polygons in the GIF, but they are generally similar and use nice easy vertex coordinates.\nNow, in order to accentuate the exterior angles, the GIF uses lines which extend beyond the vertices.\nTo achieve this, we can consider each line segment and shift the first vertex some distance in the opposite direction of the second vertex.\nTo do so, we should shift adjust our polygon representation to separate each line segment:\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\nlpoly11 = [[poly11[i],poly11[i+1]] for i in 1:length(poly11)-1];\nlpoly12 = [[poly12[i],poly12[i+1]] for i in 1:length(poly12)-1];\nlpoly21 = [[poly21[i],poly21[i+1]] for i in 1:length(poly21)-1];\nlpoly22 = [[poly22[i],poly22[i+1]] for i in 1:length(poly22)-1];\ndisplay(lpoly11)\n```\n\n::: {.cell-output .cell-output-display}\n```\n3-element Vector{Vector{Tuple{Float64, Float64}}}:\n [(-2.0, 3.0), (3.0, -3.0)]\n [(3.0, -3.0), (-4.0, -2.0)]\n [(-4.0, -2.0), (-2.0, 3.0)]\n```\n:::\n:::\n\n\n\n\n\nWe can now the vector between the first and second indices of each line segment and shift our first vertex by the negative of that vector.\nThat is a mouthful but more easily written mathematically.\nIf we consider a single line segment with vertices $v_1$ and $v_2$, we can calculate the distance between them $d = v_2 - v_1$ such that $v_1 + d = v_2$ and then redefine our first vertex in the opposite direction as $v_1^* = v_1 - l\\frac{d}{\\|d\\|}$ where $l$ is the length of the external line.\nThis boils down to the following:\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction shift_first_vertices!(lpoly, l=2)\n   for line in lpoly\n     v1 = collect(line[1]); v2 = collect(line[2])\n     d = v2 - v1\n     v1star = v1 - l*d/sqrt(d[1]^2+d[2]^2)\n     line[1] = tuple(v1star...)\n   end\nend\nshift_first_vertices!(lpoly11)\nshift_first_vertices!(lpoly12)\nshift_first_vertices!(lpoly21)\nshift_first_vertices!(lpoly22)\nfunction plot_line_segments!(ax,lpoly)\n  lines = []\n  for line in lpoly push!(lines,lines!(ax,line,color=:black)) end\n  return lines\nend\nplot_line_segments!(axes[1,1],lpoly11)\nplot_line_segments!(axes[1,2],lpoly12)\nplot_line_segments!(axes[2,1],lpoly21)\nplot_line_segments!(axes[2,2],lpoly22)\ndisplay(f)\n```\n\n::: {.cell-output .cell-output-display}\n![](polygon_angles_files/figure-html/cell-7-output-1.svg){}\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nCairoMakie.Screen{PDF}\n```\n:::\n:::\n\n\n\n\n\nOnce we have these lines in place, we can add the external angles.\nIronically, the best tool in Makie for these angle drawings is the `poly!` function which plots a filled polygon from some given vertices.\nThus, we need to compute the vertices of the arc for each angle of each polygon.\n\nThis computation can be done by taking two connected line segments $d_1$ and $d_2$, identifying the angle between them using the law of cosines $\\arccos(d_1 \\cdot d_2)$, and sampling points along the arc of given radius $l$.\nSampling the arc requires a little change of coordinates to center the points around the vertex connecting the two line segments and to rotate the standard $x$ and $y$ coordinates to align $x$ with $d_1$ and $y$ with $d_1^\\perp$.\nThis is, in my opinion, the most challenging part of the plot.\n\n\n\n::: {#14 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction angle_vertices(line1,line2,l=1)\n  v1 = collect(line1[1])\n  v2 = collect(line1[2]) # Shared vertex\n  v3 = collect(line2[2])\n  d1 = v2-v1\n  d2 = v3-v2\n  # Line segment directions (normalized\n  d1 ./= sqrt(d1[1]^2+d1[2]^2)\n  d2 ./= sqrt(d2[1]^2+d2[2]^2)\n  d1perp = [d1[2],-d1[1]]\n  vertex = tuple(v2...)\n  # Computing angle between lines, then sampling arc points\n  angle = acos(d1'*d2)\n  angle = isnan(angle) ? 0.0 : angle\n  angles = range(0, angle, length=10)\n  # arc has radius l, origin at v2, \"x\"-direction is d1, \"y\"-direction is d1perp\n  arc_points = [tuple(@.( v2 - l*(d1*cos(a) + d1perp*sin(a)))...) for a in angles]\n  vertices = vcat(vertex,arc_points,vertex)\n  return vertices\nend\nfunction plot_arcs!(ax,lpoly)\n  arcs = []\n  colors = to_colormap(:seaborn_colorblind)\n  for i in 1:length(lpoly)\n    if i+1 > length(lpoly) # The angle between the last line segment and first\n      color = colors[i+1]\n      arc_vertices = angle_vertices(lpoly[i],lpoly[1])\n    else\n      color = colors[i]\n      arc_vertices = angle_vertices(lpoly[i],lpoly[i+1])\n    end\n    push!(arcs,poly!(ax,arc_vertices,color=color))\n  end\n  return arcs\nend\nplot_arcs!(axes[1,1],lpoly11)\nplot_arcs!(axes[1,2],lpoly12)\nplot_arcs!(axes[2,1],lpoly21)\nplot_arcs!(axes[2,2],lpoly22)\ndisplay(f)\n```\n\n::: {.cell-output .cell-output-display}\n![](polygon_angles_files/figure-html/cell-8-output-1.svg){}\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nCairoMakie.Screen{PDF}\n```\n:::\n:::\n\n\n\n\n\nNow, removing the axes decorations, we have a clean plot of (almost) the first frame of the GIF:\n\n\n\n::: {#16 .cell execution_count=1}\n``` {.julia .cell-code}\nfunction remove_axis_decor!(ax)\n  ax.topspinevisible = false; ax.bottomspinevisible = false\n  ax.leftspinevisible = false; ax.rightspinevisible = false\n  ax.xgridvisible = false; ax.ygridvisible = false\n  ax.xticksvisible = false; ax.yticksvisible = false\n  ax.xticklabelsvisible = false; ax.yticklabelsvisible = false\nend\nremove_axis_decor!.(axes)\ndisplay(f)\n```\n\n::: {.cell-output .cell-output-display}\n![](polygon_angles_files/figure-html/cell-9-output-1.svg){}\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nCairoMakie.Screen{PDF}\n```\n:::\n:::\n\n\n\n\n\n\n## Animating\n\nWith the initial plot now done, to complete the animation, it remains to shrink each polygon until the angles come together to form a circle.\nThis can be simply done (with slight error) by computing the center of each polygon via averaging, centering the vertices around that center, then shrinking the vertices proportional to the number of steps in the animation.\nPutting everything together:\n\n\n\n::: {#18 .cell execution_count=1}\n``` {.julia .cell-code}\n# Initialize\nf = Figure(resolution=(800,800));\naxes = [\n  Axis(f[1,1]) Axis(f[1,2]);\n  Axis(f[2,1]) Axis(f[2,2])\n]\nfor ax in axes ax.limits = (-6,6,-6,6) end\nremove_axis_decor!.(axes)\npoly11 = [(-2.0,3.0),(3.0,-3.0),(-4.0,-2.0),(-2.0,3.0)];\npoly12 = [(-3.0,2.0),(1.0,1.0),(3.0,-2.0),(-4.0,-1.0),(-3.0,2.0)];\npoly21 = [(-1.0,3.0),(1.0,3.0),(3.0,-1.0),(1.0,-3.0),(-2.0,-2.0),(-3.0,1.0),(-1.0,3.0)];\npoly22 = [(-1.0,2.0),(1.0,2.0),(4.0,-1.0),(2.0,-3.0),(-4.0,-1.0),(-1.0,2.0)];\n# Polygon average centers\nfunction compute_center(poly)\n  vec(sum(hcat(collect.(poly)...),dims=2)./length(poly))\nend\nc11 = compute_center(poly11)\nc12 = compute_center(poly12)\nc21 = compute_center(poly21)\nc22 = compute_center(poly22)\nfunction shrink_polygon(poly,c,step,steps)\n  new_vertices = similar(poly)\n  for i in eachindex(poly)\n    vertex = collect(poly[i]) - c\n    new_vertex = @. vertex*((steps-step)/(steps))\n    new_vertices[i] = tuple((new_vertex + c)...)\n  end\n  return new_vertices\nend\n\n# Animation (somewhat inefficient since it doesn't use Observables)\nsteps = 120\nrecord(f, \"gifs/angle_gif.gif\", vcat(1:(steps-1),fill(steps-1,steps÷4),(steps-1):-1:1)) do t\n  empty!(axes[1,1].scene.plots)\n  empty!(axes[1,2].scene.plots)\n  empty!(axes[2,1].scene.plots)\n  empty!(axes[2,2].scene.plots)\n  npoly11 = shrink_polygon(poly11,c11,t,steps)\n  npoly12 = shrink_polygon(poly12,c12,t,steps)\n  npoly21 = shrink_polygon(poly21,c21,t,steps)\n  npoly22 = shrink_polygon(poly22,c22,t,steps)\n  lpoly11 = [[npoly11[i],npoly11[i+1]] for i in 1:length(npoly11)-1];\n  lpoly12 = [[npoly12[i],npoly12[i+1]] for i in 1:length(npoly12)-1];\n  lpoly21 = [[npoly21[i],npoly21[i+1]] for i in 1:length(npoly21)-1];\n  lpoly22 = [[npoly22[i],npoly22[i+1]] for i in 1:length(npoly22)-1];\n  shift_first_vertices!(lpoly11)\n  shift_first_vertices!(lpoly12)\n  shift_first_vertices!(lpoly21)\n  shift_first_vertices!(lpoly22)\n  poly!(axes[1,1],npoly11,transparency=true,color=RGBAf(1.0,0.6,0.0,0.2));\n  poly!(axes[1,2],npoly12,transparency=true,color=RGBAf(0.0,0.0,1.0,0.2));\n  poly!(axes[2,1],npoly21,transparency=true,color=RGBAf(0.5,0.0,0.5,0.2));\n  poly!(axes[2,2],npoly22,transparency=true,color=RGBAf(0.0,0.5,0.0,0.2));\n  plot_arcs!(axes[1,1],lpoly11)\n  plot_arcs!(axes[1,2],lpoly12)\n  plot_arcs!(axes[2,1],lpoly21)\n  plot_arcs!(axes[2,2],lpoly22)\n  plot_line_segments!(axes[1,1],lpoly11)\n  plot_line_segments!(axes[1,2],lpoly12)\n  plot_line_segments!(axes[2,1],lpoly21)\n  plot_line_segments!(axes[2,2],lpoly22)\nend\n```\n:::\n\n\n\n\n\n![](gifs/angle_gif.gif)\n\n",
    "supporting": [
      "polygon_angles_files"
    ],
    "filters": [],
    "includes": {}
  }
}