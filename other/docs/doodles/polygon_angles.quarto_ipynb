{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: The exterior angles of a polygon make a circle\n",
        "author: Connor Robertson\n",
        "jupyter: julia-1.10\n",
        "execute:\n",
        "  daemon: true\n",
        "categories: [Doodles]\n",
        "---\n",
        "\n",
        "\n",
        "## Overview\n",
        "I recently saw a [fun little GIF](https://gfycat.com/bluesecondblackwidowspider-geometry-math) from a weekly news email I get called the New Paper.\n",
        "It shows a simple plot of the exterior angles of a few polygons.\n",
        "As the polygons shrink, the exterior angles combine to eventually make a circle, which shows a simple graphical example of how the exterior angles of any polygon add to $2\\pi$.\n",
        "<!-- The GIF can be seen below: -->\n",
        "\n",
        "<!-- <div style='position:relative; padding-bottom:calc(100.00% + 44px)'><iframe src='https://gfycat.com/ifr/BlueSecondBlackwidowspider' frameborder='0' scrolling='no' width='100%' height='100%' style='position:absolute;top:0;left:0;' allowfullscreen></iframe></div> -->\n",
        "\n",
        "\n",
        "I thought I'd try to recreate this little GIF with my favorite plotting library `Makie.jl`.\n",
        "\n",
        "## Setting up\n",
        "Basically, we can start by getting the plots of each polygon set.\n",
        "We can then animate the sides of the polygons shrinking.\n",
        "\n",
        "To start we are going to need a `Figure` with 4 `axes`:"
      ],
      "id": "97c9ccf2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | output: false\n",
        "using Pkg;\n",
        "Pkg.activate(\".\");\n",
        "using CairoMakie;"
      ],
      "id": "296eae3a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "f = Figure(resolution=(800,800));\n",
        "axes = [\n",
        "  Axis(f[1,1]) Axis(f[1,2]);\n",
        "  Axis(f[2,1]) Axis(f[2,2])\n",
        "]\n",
        "for ax in axes ax.limits=(-6,6,-6,6) end"
      ],
      "id": "06cdabd3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can now list the vertices for each polygon:"
      ],
      "id": "f2d1de10"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "poly11 = [(-2.0,3.0),(3.0,-3.0),(-4.0,-2.0),(-2.0,3.0)];\n",
        "poly12 = [(-3.0,2.0),(1.0,1.0),(3.0,-2.0),(-4.0,-1.0),(-3.0,2.0)];\n",
        "poly21 = [(-1.0,3.0),(1.0,3.0),(3.0,-1.0),(1.0,-3.0),(-2.0,-2.0),(-3.0,1.0),(-1.0,3.0)];\n",
        "poly22 = [(-1.0,2.0),(1.0,2.0),(4.0,-1.0),(2.0,-3.0),(-4.0,-1.0),(-1.0,2.0)];"
      ],
      "id": "0820a76a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "where `poly11` is the polygon in the 1st row and 1st column.\n",
        "Plotting these lines on each respective axis, we get:"
      ],
      "id": "fe79048a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "lines!(axes[1,1],poly11,color=:black);\n",
        "lines!(axes[1,2],poly12,color=:black);\n",
        "lines!(axes[2,1],poly21,color=:black);\n",
        "lines!(axes[2,2],poly22,color=:black);\n",
        "poly!(axes[1,1],poly11,transparency=true,color=RGBAf(1.0,0.6,0.0,0.2));\n",
        "poly!(axes[1,2],poly12,transparency=true,color=RGBAf(0.0,0.0,1.0,0.2));\n",
        "poly!(axes[2,1],poly21,transparency=true,color=RGBAf(0.5,0.0,0.5,0.2));\n",
        "poly!(axes[2,2],poly22,transparency=true,color=RGBAf(0.0,0.5,0.0,0.2));\n",
        "display(f)"
      ],
      "id": "f85bb70b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "These are obviously not exactly the polygons in the GIF, but they are generally similar and use nice easy vertex coordinates.\n",
        "Now, in order to accentuate the exterior angles, the GIF uses lines which extend beyond the vertices.\n",
        "To achieve this, we can consider each line segment and shift the first vertex some distance in the opposite direction of the second vertex.\n",
        "To do so, we should shift adjust our polygon representation to separate each line segment:"
      ],
      "id": "e8b690bc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "lpoly11 = [[poly11[i],poly11[i+1]] for i in 1:length(poly11)-1];\n",
        "lpoly12 = [[poly12[i],poly12[i+1]] for i in 1:length(poly12)-1];\n",
        "lpoly21 = [[poly21[i],poly21[i+1]] for i in 1:length(poly21)-1];\n",
        "lpoly22 = [[poly22[i],poly22[i+1]] for i in 1:length(poly22)-1];\n",
        "display(lpoly11)"
      ],
      "id": "27ddf8a7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can now the vector between the first and second indices of each line segment and shift our first vertex by the negative of that vector.\n",
        "That is a mouthful but more easily written mathematically.\n",
        "If we consider a single line segment with vertices $v_1$ and $v_2$, we can calculate the distance between them $d = v_2 - v_1$ such that $v_1 + d = v_2$ and then redefine our first vertex in the opposite direction as $v_1^* = v_1 - l\\frac{d}{\\|d\\|}$ where $l$ is the length of the external line.\n",
        "This boils down to the following:"
      ],
      "id": "55a701fa"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "function shift_first_vertices!(lpoly, l=2)\n",
        "   for line in lpoly\n",
        "     v1 = collect(line[1]); v2 = collect(line[2])\n",
        "     d = v2 - v1\n",
        "     v1star = v1 - l*d/sqrt(d[1]^2+d[2]^2)\n",
        "     line[1] = tuple(v1star...)\n",
        "   end\n",
        "end\n",
        "shift_first_vertices!(lpoly11)\n",
        "shift_first_vertices!(lpoly12)\n",
        "shift_first_vertices!(lpoly21)\n",
        "shift_first_vertices!(lpoly22)\n",
        "function plot_line_segments!(ax,lpoly)\n",
        "  lines = []\n",
        "  for line in lpoly push!(lines,lines!(ax,line,color=:black)) end\n",
        "  return lines\n",
        "end\n",
        "plot_line_segments!(axes[1,1],lpoly11)\n",
        "plot_line_segments!(axes[1,2],lpoly12)\n",
        "plot_line_segments!(axes[2,1],lpoly21)\n",
        "plot_line_segments!(axes[2,2],lpoly22)\n",
        "display(f)"
      ],
      "id": "85f913bd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Once we have these lines in place, we can add the external angles.\n",
        "Ironically, the best tool in Makie for these angle drawings is the `poly!` function which plots a filled polygon from some given vertices.\n",
        "Thus, we need to compute the vertices of the arc for each angle of each polygon.\n",
        "\n",
        "This computation can be done by taking two connected line segments $d_1$ and $d_2$, identifying the angle between them using the law of cosines $\\arccos(d_1 \\cdot d_2)$, and sampling points along the arc of given radius $l$.\n",
        "Sampling the arc requires a little change of coordinates to center the points around the vertex connecting the two line segments and to rotate the standard $x$ and $y$ coordinates to align $x$ with $d_1$ and $y$ with $d_1^\\perp$.\n",
        "This is, in my opinion, the most challenging part of the plot."
      ],
      "id": "23600f4e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "function angle_vertices(line1,line2,l=1)\n",
        "  v1 = collect(line1[1])\n",
        "  v2 = collect(line1[2]) # Shared vertex\n",
        "  v3 = collect(line2[2])\n",
        "  d1 = v2-v1\n",
        "  d2 = v3-v2\n",
        "  # Line segment directions (normalized\n",
        "  d1 ./= sqrt(d1[1]^2+d1[2]^2)\n",
        "  d2 ./= sqrt(d2[1]^2+d2[2]^2)\n",
        "  d1perp = [d1[2],-d1[1]]\n",
        "  vertex = tuple(v2...)\n",
        "  # Computing angle between lines, then sampling arc points\n",
        "  angle = acos(d1'*d2)\n",
        "  angle = isnan(angle) ? 0.0 : angle\n",
        "  angles = range(0, angle, length=10)\n",
        "  # arc has radius l, origin at v2, \"x\"-direction is d1, \"y\"-direction is d1perp\n",
        "  arc_points = [tuple(@.( v2 - l*(d1*cos(a) + d1perp*sin(a)))...) for a in angles]\n",
        "  vertices = vcat(vertex,arc_points,vertex)\n",
        "  return vertices\n",
        "end\n",
        "function plot_arcs!(ax,lpoly)\n",
        "  arcs = []\n",
        "  colors = to_colormap(:seaborn_colorblind)\n",
        "  for i in 1:length(lpoly)\n",
        "    if i+1 > length(lpoly) # The angle between the last line segment and first\n",
        "      color = colors[i+1]\n",
        "      arc_vertices = angle_vertices(lpoly[i],lpoly[1])\n",
        "    else\n",
        "      color = colors[i]\n",
        "      arc_vertices = angle_vertices(lpoly[i],lpoly[i+1])\n",
        "    end\n",
        "    push!(arcs,poly!(ax,arc_vertices,color=color))\n",
        "  end\n",
        "  return arcs\n",
        "end\n",
        "plot_arcs!(axes[1,1],lpoly11)\n",
        "plot_arcs!(axes[1,2],lpoly12)\n",
        "plot_arcs!(axes[2,1],lpoly21)\n",
        "plot_arcs!(axes[2,2],lpoly22)\n",
        "display(f)"
      ],
      "id": "5c750826",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now, removing the axes decorations, we have a clean plot of (almost) the first frame of the GIF:"
      ],
      "id": "8d6b6b9e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "function remove_axis_decor!(ax)\n",
        "  ax.topspinevisible = false; ax.bottomspinevisible = false\n",
        "  ax.leftspinevisible = false; ax.rightspinevisible = false\n",
        "  ax.xgridvisible = false; ax.ygridvisible = false\n",
        "  ax.xticksvisible = false; ax.yticksvisible = false\n",
        "  ax.xticklabelsvisible = false; ax.yticklabelsvisible = false\n",
        "end\n",
        "remove_axis_decor!.(axes)\n",
        "display(f)"
      ],
      "id": "7af01868",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Animating\n",
        "\n",
        "With the initial plot now done, to complete the animation, it remains to shrink each polygon until the angles come together to form a circle.\n",
        "This can be simply done (with slight error) by computing the center of each polygon via averaging, centering the vertices around that center, then shrinking the vertices proportional to the number of steps in the animation.\n",
        "Putting everything together:"
      ],
      "id": "16845fdb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# | output: false\n",
        "# Initialize\n",
        "f = Figure(resolution=(800,800));\n",
        "axes = [\n",
        "  Axis(f[1,1]) Axis(f[1,2]);\n",
        "  Axis(f[2,1]) Axis(f[2,2])\n",
        "]\n",
        "for ax in axes ax.limits = (-6,6,-6,6) end\n",
        "remove_axis_decor!.(axes)\n",
        "poly11 = [(-2.0,3.0),(3.0,-3.0),(-4.0,-2.0),(-2.0,3.0)];\n",
        "poly12 = [(-3.0,2.0),(1.0,1.0),(3.0,-2.0),(-4.0,-1.0),(-3.0,2.0)];\n",
        "poly21 = [(-1.0,3.0),(1.0,3.0),(3.0,-1.0),(1.0,-3.0),(-2.0,-2.0),(-3.0,1.0),(-1.0,3.0)];\n",
        "poly22 = [(-1.0,2.0),(1.0,2.0),(4.0,-1.0),(2.0,-3.0),(-4.0,-1.0),(-1.0,2.0)];\n",
        "# Polygon average centers\n",
        "function compute_center(poly)\n",
        "  vec(sum(hcat(collect.(poly)...),dims=2)./length(poly))\n",
        "end\n",
        "c11 = compute_center(poly11)\n",
        "c12 = compute_center(poly12)\n",
        "c21 = compute_center(poly21)\n",
        "c22 = compute_center(poly22)\n",
        "function shrink_polygon(poly,c,step,steps)\n",
        "  new_vertices = similar(poly)\n",
        "  for i in eachindex(poly)\n",
        "    vertex = collect(poly[i]) - c\n",
        "    new_vertex = @. vertex*((steps-step)/(steps))\n",
        "    new_vertices[i] = tuple((new_vertex + c)...)\n",
        "  end\n",
        "  return new_vertices\n",
        "end\n",
        "\n",
        "# Animation (somewhat inefficient since it doesn't use Observables)\n",
        "steps = 120\n",
        "record(f, \"gifs/angle_gif.gif\", vcat(1:(steps-1),fill(steps-1,steps÷4),(steps-1):-1:1)) do t\n",
        "  empty!(axes[1,1].scene.plots)\n",
        "  empty!(axes[1,2].scene.plots)\n",
        "  empty!(axes[2,1].scene.plots)\n",
        "  empty!(axes[2,2].scene.plots)\n",
        "  npoly11 = shrink_polygon(poly11,c11,t,steps)\n",
        "  npoly12 = shrink_polygon(poly12,c12,t,steps)\n",
        "  npoly21 = shrink_polygon(poly21,c21,t,steps)\n",
        "  npoly22 = shrink_polygon(poly22,c22,t,steps)\n",
        "  lpoly11 = [[npoly11[i],npoly11[i+1]] for i in 1:length(npoly11)-1];\n",
        "  lpoly12 = [[npoly12[i],npoly12[i+1]] for i in 1:length(npoly12)-1];\n",
        "  lpoly21 = [[npoly21[i],npoly21[i+1]] for i in 1:length(npoly21)-1];\n",
        "  lpoly22 = [[npoly22[i],npoly22[i+1]] for i in 1:length(npoly22)-1];\n",
        "  shift_first_vertices!(lpoly11)\n",
        "  shift_first_vertices!(lpoly12)\n",
        "  shift_first_vertices!(lpoly21)\n",
        "  shift_first_vertices!(lpoly22)\n",
        "  poly!(axes[1,1],npoly11,transparency=true,color=RGBAf(1.0,0.6,0.0,0.2));\n",
        "  poly!(axes[1,2],npoly12,transparency=true,color=RGBAf(0.0,0.0,1.0,0.2));\n",
        "  poly!(axes[2,1],npoly21,transparency=true,color=RGBAf(0.5,0.0,0.5,0.2));\n",
        "  poly!(axes[2,2],npoly22,transparency=true,color=RGBAf(0.0,0.5,0.0,0.2));\n",
        "  plot_arcs!(axes[1,1],lpoly11)\n",
        "  plot_arcs!(axes[1,2],lpoly12)\n",
        "  plot_arcs!(axes[2,1],lpoly21)\n",
        "  plot_arcs!(axes[2,2],lpoly22)\n",
        "  plot_line_segments!(axes[1,1],lpoly11)\n",
        "  plot_line_segments!(axes[1,2],lpoly12)\n",
        "  plot_line_segments!(axes[2,1],lpoly21)\n",
        "  plot_line_segments!(axes[2,2],lpoly22)\n",
        "end"
      ],
      "id": "f1bdfde2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![](gifs/angle_gif.gif)"
      ],
      "id": "210df870"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "julia-1.10",
      "language": "julia",
      "display_name": "Julia 1.10.3",
      "path": "/Users/cjrobe/Library/Jupyter/kernels/julia-1.10"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}